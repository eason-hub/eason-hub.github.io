{"meta":{"title":"07♥的主页","subtitle":"","description":"","author":"lqx","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"随记一","slug":"随记一","date":"2021-04-18T13:23:51.000Z","updated":"2021-04-18T13:28:54.500Z","comments":true,"path":"2021/04/18/随记一/","link":"","permalink":"http://example.com/2021/04/18/%E9%9A%8F%E8%AE%B0%E4%B8%80/","excerpt":"","text":"今天在刷知乎的过程中想到了一个问题“为什么你喜欢刷知乎？” 看到一篇很有诗意的回答，记录下来： 当你窝在宿舍那小小的几平方米，电脑桌面满是下好的论文。身边的人各自做着各自的事，白色灯管里发出的光总是带了那么点疏离的意味。饭早就匆匆在食堂解决过了，炊烟中的烟火气成了宿舍楼群望而不得的人间。楼下偶尔能传上来附近居民锻炼时候发出的声响，老的少的，有点肆无忌惮的热闹。你越发觉得自己身处一座孤岛，不算与世隔绝，但对这座城市总有着那么点说不清，道不明的感觉，就像白色灯管发出的灯光，很亮，也很疏离。这时候你很想去看看别人的故事，就好像能够顺带路过别人的人生。 你关注了知乎中很多话题，就比如：你最怦然心动的一个瞬间是什么？你最感动的体验是怎样的？……诸如此类。 你跟着答案一起穿过窄巷子，和一个老爷爷一起听昆曲咿咿呀呀；一起走进一家老旧的咖啡馆，听老板给讲两个时光中的故事；又或者一起在一个下了雪的下午，围坐在暖炉旁边感受阳光的气息…… 你突然觉得你的孤岛中，有了那么点摇摇曳曳的闪光。 ——来自知乎 看完很有感悟，其实知乎上的各种成功人士的答案并没有让我变成所谓的“成功人士” 翻了自己的回答，无外乎都是希望找到看法一样的人，一起分享快乐，把不能和周围人说的，或者是找不到倾诉的，分享给知乎上的朋友 这对我而言足够了~","categories":[{"name":"随记","slug":"随记","permalink":"http://example.com/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://example.com/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"数据库知识点","slug":"数据库知识点","date":"2021-04-14T09:50:52.000Z","updated":"2021-04-14T09:51:37.616Z","comments":true,"path":"2021/04/14/数据库知识点/","link":"","permalink":"http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"数据库怎么加快查询速度：尽可能优化查询语句，避免使用order by和group by(会占用大量的临时空间，可创建视图来代替)， 避免使用like等通配符正则表达式，创建索引加快 123SELECT * FROM table1 WHERE field1&lt;&#x3D;10000 AND field1&gt;&#x3D;0;SELECT * FROM table1 WHERE field1&gt;&#x3D;0 AND field1&lt;&#x3D;10000;&#x2F;&#x2F;更好，where语句中把最具限制性的条件放在最前面 创建索引： 1create index index_name on table_name(column_list) [tablespace tablespace_name] 举个栗子： 1234567891011如果我们经常对emp表进行按照empno来查询某个员工的信息，SQL&gt; select * from emp where empno&#x3D;7788; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7788 SCOTT ANALYST 7566 1987-4-19 3000.00 20我们就应该对empno这一列建一个索引。create index indx_on_empno on emp(empno) tablespace users; 1234567891011121314151617如果我们经常查询某个部门工资大于1000的员工信息，那么我们就可以在job和sal列上建立所以，这叫组合索引：SQL&gt; select * from emp 2 where job&#x3D;&#39;SALESMAN&#39; and sal&gt;1000; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7499 ALLEN SALESMAN 7698 1981-2-20 1600.00 300.00 30 7521 WARD SALESMAN 7698 1981-2-22 1250.00 500.00 30 7654 MARTIN SALESMAN 7698 1981-9-28 1250.00 1400.00 30 7844 TURNER SALESMAN 7698 1981-9-8 1500.00 0.00 30 create index indx_on_job_sal on emp(job,sal)tablespace users; 数据库索引的底层原理——B树索引 数据库也好，磁盘查找也好，都是将部分数据调入内存后，进行查找比对，这样就会涉及到一个调入数据进入内存的问题，要调入多少数据进入内存，就是设计数据在外存中的存储的重点了！！！ B树的结构：图片/5.png B树的阶数不像二叉树一样必须是2，而是不限制阶数，因此就可以变得“矮胖的” 数据库索引的分类： 唯一索引： 不允许其中的任何两行具有相同的索引值 例如在employee表中name上创建索引，就表示任何两个员工都不能具有相同的姓名 主键索引: 在数据库创建主键后自动创建主键索引，主键索引也是唯一索引的特殊情况 聚集索引 数据库中的锁锁的分类：数据库系统角度：排他锁、共享锁、更新锁 程序员角度：悲观锁、乐观锁 悲观锁悲观锁，像名字一样，每次用到数据的时候都会认为别人会对数据进行修改，所以每次使用数据都会上锁，并且悲观锁增加了死锁的机会 这种锁都是在操作之前先上锁 悲观锁按照使用性质划分： 共享锁（S锁、读锁）——用于所有的只读操作，并非是独占的，允许多个并发的事务来读取数据，但是任何的事务都不能对其进行修改，读取完毕后，立即释放锁 123456SELECT * FROM my_table&#x2F;&#x2F;先锁定第一页，读取后释放，再锁第二页SELECT * FROM my_table HOLDLOCK&#x2F;&#x2F;要求整个查询的过程中，保持对表的锁定 排他锁（X锁、写锁）——事务为对象设置排他锁后，其他事务不允许读或写，X锁不同于S锁，直到事务结束后才能被释放 更新锁（U锁）——在修改操作之前就锁定可能要修改的资源，避免产生死锁 1234可能产生死锁的原因：当A事务申请对U资源的共享锁时，B事务也在使用共享锁读P资源数据；然后A事务设置排他锁来对P写数据，但是B事务也要申请排他锁来对U写数据，对方都想等待记录，但是对方都不放资源，造成死锁当A事务在写P资源之前，首先对P设置更新锁，这样B事务就不会再对P上锁，不会发生死锁 悲观锁按照所用范围划分： 行锁、表锁 乐观锁乐观锁，就是每次使用数据的时候，都认为别人不会进行修改，所以就不会上锁，但是再更新的时候会判断一下在操作期间别人有没有更新这个数据，可以使用版本号机制 版本号： 给数据表增加version字段，每次更新将字段+1，读数据的时候将version读入，要更新数据后比较version是否发生了变化： 发生了变化就反馈给用户，让用户自己判断，可以重新开始，并且这里面判断version和用户更新为一个原子单元执行，否则会出现，判断后没有更新，但是在判断过程中发生了更新，没有反馈给用户的情况 时间戳——同版本号 这里的时间戳不是系统时间而是数据库服务器时间 待更新字段 不另外设置时间戳或者版本号等标识，而是直接比较数据库中的某个字段的数据是否发生了改变 两者不同点悲观锁虽然安全，但是也使得数据库效率下降，性能开销变大，对于长事务来说更为明显 并发控制可能产生的两种不良情况死锁 预防方法： 一次封锁法、顺序封锁法（更新锁） 活锁 按照事务的优先级不同，比如T1事务封锁数据R，之后T2请求封锁R，T3也请求封锁R，T4也请求封锁R，但是这里T2的优先级最低就导致了T2永远也等不到数据，这里可以使用先来先服务策略避免 对于高并发的情况下建议尽量使用乐观锁 首先是悲观锁增加了产生死锁的概率，一旦产生死锁，对系统的消耗巨大，长时间限制其他用户的访问，并发性并不好； 而乐观锁减少了过多的加锁的步骤，提高性能，并且乐观锁出现差错的情况纪律比较小 乐观锁可能失效的情况： 123456常见的取当前ID字段的最大值＋1作为新ID版本号字段 version 默认值为 0用户A读取了某个记录准备修改它该记录正好是ID最大的记录，且之前没被修改过，version 为默认值 0在用户A读取完成后，用户B恰好删除了该记录。之后，用户C又插入了一个新记录此时，阴差阳错的，新插入的记录的ID与用户A读取的记录的ID是一致的， 而版本号两者又都是默认值0","categories":[{"name":"计算机知识点","slug":"计算机知识点","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E7%82%B9/"}],"tags":[{"name":"数据库知识点","slug":"数据库知识点","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"计算机网络知识点","slug":"计算机网络知识点","date":"2021-04-14T09:49:07.000Z","updated":"2021-04-14T09:50:34.606Z","comments":true,"path":"2021/04/14/计算机网络知识点/","link":"","permalink":"http://example.com/2021/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"Http常见状态码：http状态码表示客户端http请求的返回结果，标记服务器端的处理是否正常或者是出现的错误 其中第一位指定了相应类别 1xx 接受的请求正在处理2xx 请求正常处理完毕3xx 需要进行附加操作来完成请求（比如重定向）4xx 客户端请求错误，服务器无法处理5xx 服务器处理请求错误 2xx200 OK 请求正常处理并返回204 No Content 返回的报文中没有资源返回206 Patial Content 3xx301 Moved Permanently 永久性重定向 请求的资源被分配了新的URL302 Found 临时重定向，后续可能还会更改URL303 See Other 类似302，但是表明客户端应采取get方式获取资源304 Not Modified307 Temporary Redirect 临时重定向和303相同 4xx400 Bad Request 报文中存在语法错误401 Unauthorized 未经许可，要通过http认证403 Forbidden 服务器拒绝本次访问404 Not Found 服务器上无法找到请求的资源 5xx500 Inter Server Error 服务器执行请求时发生错误503 Server Unavailable 服务器暂时处于超负载运行中，无法处理请求 tcp为什么比udp可靠：tcp是面向连接的而udp无连接直接发送数据 tcp提供可靠地服务，通过tcp传送的数据，无差错，不丢失，不重复，顺序不变；而udp只是尽可能的交付数据 tcp在确认客户端接收到完整信息后，才会删除服务端系统中数据缓存 tcp的可靠服务基于：校验和，重传机制，序号标识，滑动窗口，确认应答 但是tcp只是点到点的，udp支持多对多传输通信","categories":[{"name":"计算机知识","slug":"计算机知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"JVM探究","slug":"JVM探究","date":"2021-04-14T09:47:46.000Z","updated":"2021-04-14T09:48:31.863Z","comments":true,"path":"2021/04/14/JVM探究/","link":"","permalink":"http://example.com/2021/04/14/JVM%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"概述本机虚拟机类型——JavaHotSpot 1cmd→ java -version JVM位置JVM运行在os之上，JVM是使用C写的程序；JRE包含了JVM； JDK包含JRE，JRE包含JVMJDK：Java development kit——Java开发工具包JRE：Java runtime environment——Java的运行环境（lib+bin）JVM：Java Virtual machine——Java虚拟机 Java平台下，所有的Java程序都要在JRE环境下运行，JVM解释class文件的时候，需要调用解释用到的类库lib;但是JRE不包含Java的运行工具（编译器，调试器等） JDK就包括了Java的运行环境、工具（javac）、Java基础类库（Java API：Java的应用程序接口，包括已经写好的Java class文件等，可以直接调用） 但是我的电脑中有两个相同版本的JRE和JDK: JDK内外的JRE都可以为Java提供开发的运行环境，但是JDK自带的开发工具只能使用自己的JRE 实际开发：JDK调用本地API开发Java程序，通过JDK中javac工具编译成Java.class后，在外部JRE上运行字节码文件，JVM来解释.class文件变成机器语言后再不同的os上使用 11.jpg 在JVM中垃圾只能存在于堆和方法区中，栈、本地方法栈、程序计数器内不可能有垃圾，也不会有垃圾回收，否则无法弹出的话，最下面的main方法无法弹出，程序没有出口 因此JVM的调优就是在堆内调优 类加载器 —— 加载.class文件类加载器主要负责三项任务：载入、链接、初始化 当new Student()时，该Student类的具体实例引用在栈中，而实例对象放在堆中 类加载器包含：虚拟机自带加载器，启动类（根）加载器(EXCClassLoader)（在rt.jar中），扩展类加载器，应用程序加载器（AppClassLoader） 1234567class AA.getClass();&#x2F;&#x2F;获取类名A.getClassLoader();&#x2F;&#x2F;获取类加载器A.getClassLoader().getParent();&#x2F;&#x2F;获取上层父类加载器 双亲（上层）委派机制：——向上委托，向下加载 在类加载器为了生成.class文件时，首先按照如下顺序找到类加载器： APP–&gt;EXC–&gt;ROOT–&gt;null(因为Java的底层是用C、C++来写的，丢掉了指针，将内存管理交给JVM来做) 最后找到根加载器进行加载，没有的话在回退找到加载器，都找不到的话就会报错:Class Not Found 这样安全性高的机制也必然导致了性能下降 沙箱安全机制 对于非本地的代码，在沙箱中运行~没写完(～￣▽￣)～ Java实例化和初始化的区别123public class A&#123; A() &#123;&#125;&#125; 类的初始化是构造函数完成的，在程序开始run的一瞬间，类以及静态的东西都在内存中开始初始化 1A a&#x3D;new A();&#x2F;&#x2F;实例化 类的加载只执行一次，也就是初始化一次，只有一个类的对象，而实例化是有一个new就会有一个实例化对象 1A a&#x3D;null;&#x2F;&#x2F;这只是声明 这也就解释了为什么main是static的情况： 在Java中所有的程序都是在类的基础上运行的，但是刚刚运行的程序没有任何类，没有类怎么加载类，没有加载类怎么出现类，这样的话就陷入了死循环； 利用static关键字，因为static不需要依赖实例对象而存在，所以通过static main()来创建一系列的对象，这样就可以继续加载其他的类了 native关键字12345public class Demo&#123; public void hello();&#x2F;&#x2F;接口报错，只能在抽象类中 public native void hello();&#x2F;&#x2F;成功&#125; 包含native关键字的方法，不在受到java管辖，而是调用底层C语言的库！ 会进入本地方法栈 Native Method Statck，在调用JNI（Java Native interface）接口找到本地方法接口，在调用本地方法库就可以扩展Java的方法 在JVM中的本地方法栈中登记了native方法，在最终执行的时候找到本地方法库的方法 例如Java程序驱动打印机，就可以使用native关键字 PC程序计数器每个线程都有一个程序计数器，是线程私有的，就相当于一个指针，指向下一条要执行的语句 方法区Java虚拟机中明确说明：方法区 作为堆的一部分，但是是独立于堆的内存空间 方法区和堆一样，是线程共享的内存区域 方法区在JVM启动时被创建，和堆一样都是不连续的物理空间，空间大小可以扩展 方法区的大小决定了可以保存多少类，定义了太多类或者过多的引用第三方的jar包，也会导致方法区溢出 关闭JVM就会释放这个方法区的内存 1234567891011public class Test&#123; private int a; private String name&#x3D;&quot;lingqixin&quot;; &#x2F;&#x2F;当name赋初值后这个初值就会放在常量池中 public static void main(String[] args) &#123; Test test1&#x3D;new Test(); test1.name&#x3D;&quot;new lingqixin&quot;; &#x2F;&#x2F;要是没有被赋新的值，就要从常量池中获得 &#125;&#125; JVM中的堆和栈1.栈： 线程结束，栈就会Over 栈中存放的内容： 函数中定义的八大基本类型（char,short,int,float,double,long,boolean,byte)以及引用变量都在栈中分配（就相当于数组的名称） 123int a&#x3D;3;int b&#x3D;3; 2.堆： 栈是线程级别的，但是一个JVM只有一个堆 当类加载器加载了类后，会将该类的方法，常量值，变量值，保存引用值的对象 堆内存分成三个区域： 新生代：伊甸园（new产生）、幸存区0、幸存区1老年代：永久代（jdk1.8后被元空间取代）！！ GC垃圾回收主要在伊甸园和老年代 当出现OOM的堆内存满了的错误时","categories":[{"name":"Java原理","slug":"Java原理","permalink":"http://example.com/categories/Java%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"Java知识点","slug":"Java知识点","date":"2021-04-14T09:46:10.000Z","updated":"2021-04-14T09:47:26.825Z","comments":true,"path":"2021/04/14/Java知识点/","link":"","permalink":"http://example.com/2021/04/14/Java%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"区别equals、hashCode()和====说明： 对于8个基本数据类型，判断的是操作数的值是否相等 两个类对象==判断，是判断其在栈中所指向的堆中的地址值 1234String s1&#x3D;&quot;tom&quot;;String s2&#x3D;&quot;tom&quot;;System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;返回结果为true 这里第一个s1在JVM的堆的常量池中已经创建了一个叫做”tom”的常量，s1存放的是堆中的地址 在s2时，因为常量池中已经有了一个”tom”，所以s2也指向该”tom”，s1与s2的指向地址相同 1234String s1&#x3D;&quot;tom&quot;;String s2&#x3D;new String(&quot;tom&quot;);System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;返回结果为false 这里new之后相当于在堆内存中重新开辟一段新的空间去存储”tom”，因此s1,s2指向的地址不相同 反过来看equals源码: 12345678910111213141516171819202122232425public boolean equals(Object anObject)&#123; if(this&#x3D;&#x3D;anObject)&#123; return true; &#125;&#x2F;&#x2F;首先判断s1和s2 &#x3D;&#x3D;来比较地址值是否相同，不相同的话，往下进行 if(anObject instanceof String)&#123;&#x2F;&#x2F;instanceof用来判断传入的值是否为String类型的实例，如果不是直接false String anotherString &#x3D; (String) anObject;&#x2F;&#x2F;将s2转换为String int n&#x3D;this.value.length;&#x2F;&#x2F;获取s1的长度 if(n &#x3D;&#x3D; anotherString.value.length)&#123;&#x2F;&#x2F;首先判断两者长度是否相同，不同就直接false char v1[] &#x3D; value; char v2[] &#x3D; anotherString.value; &#x2F;&#x2F;拆分字符串为数组[&#39;t&#39;,&#39;o&#39;,&#39;m&#39;] int i&#x3D;0; while(n-- !&#x3D;0)&#123; if(v1[i]!&#x3D;v2[i]) return false; i++; &#125; return true;&#x2F;&#x2F;字符串完全相同，返回true &#125; &#125; return false;&#125; equals说明： 1.equals在Object中比较的还是对象的内存地址，而String方法对equals进行了重写，因此String中比较的就是对象的值； 2.String类型创建对象首先要看zai在JVM的堆常量池中是否有相同的要创建的值，如果有就赋给当前的引用 hashCode()说明： hashCode()是Object中的native方法，用于获取对象的哈希值，用于确定该对象在哈希表中的索引位置 也就是将数据的内部存储地址转换成一个整数然后返回 1public native int hashCode(); hashCode()的存在也决定了数据在哈希表中的存储方式： //这里有个图片 ./blog/source/2.jpg 要放入到哈希表中的元素首先要经历一些判断： （1）通过hashCode()来获取hash值，这个值也就是通过哈希函数获取的在数组中的位置值，根据哈希函数的运算规则，这个值有可能相同，不同的话，那就绝对不存在这个对象，可以创建新的空间放入到集合中 （2）如果hash的值相同，但是也不等说明两个完全一样，要进行equals判断，发现与已经存在的对象equals值也相同的话，就可以舍弃；否则创建该对象 这就得到了hashCode()和equals的关系： 如果重写了equals方法，有必要重写hashCode()方法的φ(*￣0￣)这是为啥。。。 两个对象equals()返回为true，则hashCode()必为true 两个对象equals()返回false，则hashCode()不一定就不同 两个对象hashCode()返回相同int，则equals()返回不一定为true 两个对象hashCode()返回不同int，则equals()返回必定为false 基本数据类型所占字节大小此处有图片./blog/source/3.png 基本数据类型和对应的包装类的区分 Integer和int区别: Integer是int的包装类，int是Java的基本数据类型 Integer要实例化才使用，int不用 Integer默认为null,int为0 1234Integer i &#x3D; new Integer(100);int j &#x3D; 100；System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true Integer和int相比较的时候，只要值相同结果相等，比较时Java将Integer自动拆包装为int 1234Integer i &#x3D; new Integer(100);Integer j &#x3D; 100;System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false 当变量值在-128~127，非new生成的Integer对象是常量池的中的，而new生成的是堆中新建的，内存地址不同； 当不在区间时，非new生成的最终按照new处理，两个地址同样不同 也解释了下面： 12345678Integer i &#x3D; 100;Integer j &#x3D; 100;System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;trueInteger i &#x3D; 128;Integer j &#x3D; 128;System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false Java中this详解this指向的是当前对象的引用this.方法名称——用来访问本类的成员方法 Java中的块{}以及实例化和初始化顺序1.{}定义在方法中，就是调用方法的时候执行 2.{}定义在类中，方法外，表示一个构造块；在创建对象的时候，首先找构造器，有构造块，先执行块中内容，再执行构造器中内容 3.static{}定义在类中，方法外，表示一个静态块；在第一次类加载完毕后执行，并且只执行一次，静态块优先于方法执行 4.synchronized(){}同步代码块，写在方法中 执行顺序：静态块(静态变量：按照编写顺序来，并且都只加载一次)→主方法（main）→成员变量、构造块（按照编写顺序来）→构造器代码→静态方法（调用了才加载） 1234567891011121314151617181920212223242526272829public class Demo &#123; int a &#x3D; print(3);&#x2F;&#x2F;5.加载成员变量，调用print(3)，输出&quot;实例3&quot; public Demo() &#123; System.out.println(&quot;构造方法&quot;);&#x2F;&#x2F;8.最后执行构造方法 &#125; &#123; System.out.println(&quot;非静态块&quot;);&#x2F;&#x2F;6.顺序执行到非静态块，输出&quot;非静态块&quot; &#125; int b &#x3D; print(4);&#x2F;&#x2F;7.加载成员变量，调用print(4)，输出&quot;实例4&quot; public int print(int value) &#123; System.out.println(&quot;实例&quot; + value); return value; &#125; static int i &#x3D; printStatic(1);&#x2F;&#x2F;1.加载静态变量，调用方法printStatic()，输出&quot;静态1&quot; static &#123; System.out.println(&quot;静态块&quot;); &#125;&#x2F;&#x2F;2.按照顺序加载静态块，输出&quot;静态块&quot; static int j &#x3D; printStatic(2);&#x2F;&#x2F;3.调用printStatic()，输出&quot;静态块2&quot; public static int printStatic(int value) &#123; System.out.println(&quot;静态&quot; + value); return value; &#125; public static void main(String[] args) &#123; new Demo();&#x2F;&#x2F;4.开始执行主方法，到了类实例化过程 &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java集合Collection——List接口02","slug":"Java集合Collection——List接口02","date":"2021-04-07T11:02:17.000Z","updated":"2021-04-07T11:27:47.555Z","comments":true,"path":"2021/04/07/Java集合Collection——List接口02/","link":"","permalink":"http://example.com/2021/04/07/Java%E9%9B%86%E5%90%88Collection%E2%80%94%E2%80%94List%E6%8E%A5%E5%8F%A302/","excerpt":"","text":"ArrayList子类ArrayList子类特点1.ArrayList类可以加入任何值，加入null,也可以加入多个null 2.ArrayList底层由数组来实现的 3.但是ArrayList线程不安全，可是执行效率高，在多线程情况下不建议使用ArrayList add方法源码： 123456public boolean add(E e)&#123; ensureCapacityInternal(size+1); elementDatal[size++]&#x3D;e; return true;&#125; 源码中没有synchronized同步，就没有线程安全的控制 ArrayList的底层机制与源码分析1.ArrayList维护了一个Object类型的数组——elementData.transient Object[] elementData transient表示瞬间的、短暂的，也就是当对象被该关键字修饰时，表示该属性不会被序列化 2.当创建ArrayList对象时，如果使用的时无参构造器ArrayList()，则初始的elementData容量为0，第一次添加数据，扩容为10；以后再次扩容elementData为1.5倍 3.如果使用的是指定大小的构造器，初始的elementData容量为指定大小；如果需要扩容，则直接扩容为elementData的1.5倍，后续都是前者的1.5倍，以此类推","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"}]},{"title":"Java集合Collection——List接口","slug":"Java集合Collection——List接口","date":"2021-04-07T08:14:45.000Z","updated":"2021-04-07T11:27:34.761Z","comments":true,"path":"2021/04/07/Java集合Collection——List接口/","link":"","permalink":"http://example.com/2021/04/07/Java%E9%9B%86%E5%90%88Collection%E2%80%94%E2%80%94List%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"List特点1.List是Collection接口的子接口 2.List集合中元素有序，元素可以重复，按照存放的顺序来取出元素 3.List接口中的每一个元素都有其对应的顺序索引，也就是List的底层为数组 1list.get(index);&#x2F;&#x2F;也就是支持get(index)通过索引获取数据index从0开始 4.Java API中实现List接口的类很多：Vector、ArrayList、LinkedList、Stack… List常用方法1.指定位置插入元素 1void add(int index,Object ele); 当不指定index时，默认插入到List的末尾 2.指定位置插入集合元素 1boolean addAll(int index,Collection eles); 3.获取指定位置元素 1Object get(int index); 4.返回obj在集合中首次出现的位置 1int indexOf(Object obj); 5.返回obj在集合中最后一次出现的位置 1int lastIndexOf(Object obj); 6.移除指定index位置的元素，并返回此元素 1Object remove(int index); 7.替换某位置的元素为另一个值:当没有这个index时，控制台报错：IndexOutOfBoundException 1Object set(int index, Object ele); 8.返回从fromIndex到toIndex的集合 1List subList(int fromIndex,int toIndex); 但是实际返回的集合是下标[fromIndex,toIndex-1]!!! List常用遍历方法iterator模式增强for模式","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"}]},{"title":"粤语歌——《完》","slug":"粤语歌——《完》","date":"2021-04-06T08:01:42.000Z","updated":"2021-04-06T08:16:16.550Z","comments":true,"path":"2021/04/06/粤语歌——《完》/","link":"","permalink":"http://example.com/2021/04/06/%E7%B2%A4%E8%AF%AD%E6%AD%8C%E2%80%94%E2%80%94%E3%80%8A%E5%AE%8C%E3%80%8B/","excerpt":"","text":"http://music.163.com/song?id=64048&amp;userid=1659092624 手一僵 眼闭着 未能延着 别求延着","categories":[],"tags":[{"name":"粤语歌","slug":"粤语歌","permalink":"http://example.com/tags/%E7%B2%A4%E8%AF%AD%E6%AD%8C/"},{"name":"陈奕迅","slug":"陈奕迅","permalink":"http://example.com/tags/%E9%99%88%E5%A5%95%E8%BF%85/"}]},{"title":"搭建博客问题汇总","slug":"搭建博客问题汇总","date":"2021-04-03T14:33:05.000Z","updated":"2021-04-04T02:59:04.576Z","comments":true,"path":"2021/04/03/搭建博客问题汇总/","link":"","permalink":"http://example.com/2021/04/03/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"","text":"1.网络问题： 可能因为翻墙吧。。。所有外网访问都是问题（额） 1OpenSSL SSL_read: Connection was reset, errno 10054 大概是网络不稳定，链接超时导致的，还有就是ssl密钥？执行这个命令，解除ssl验证： 1git config --global http.sslVerify &quot;false&quot; 第一次执行这条命令的时候会有git的ssl链接输入密码？？（大概是，具体我查查） 我的天完事开头难，我就插入个上面的截图给我搞得心态爆炸了o(*≧▽≦)ツ┏━┓ 2.还是网络问题： 因为要翻墙，但是挂的梯子还是不稳定总是出现“Failed to connect to github.com port 443: Timed out”的问题，干脆面向百度解决问题，修改了hosts文件，对访问github别在受限了啊啊啊啊啊 在hosts文件里面加上这个： 123#github#192.30.253.112 github.com#151.101.185.194 github.global.ssl.fastly.net 因为hosts为系统文件，在修改之前右键点击属性-安全-找到电脑用户Users-增加一下权限就可以了 绝了绝了！！！！！修改了第二条，第一条的指令不用加上了！！！！！掘了掘了！！！好吧。。并没有，我试了一次，还是要第一条emmmmmm","categories":[],"tags":[]},{"title":"idea快捷键汇总","slug":"idea快捷键汇总","date":"2021-04-03T13:03:07.000Z","updated":"2021-04-03T13:03:07.301Z","comments":true,"path":"2021/04/03/idea快捷键汇总/","link":"","permalink":"http://example.com/2021/04/03/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"手撕算法——查找","slug":"手撕算法——查找","date":"2021-04-02T09:16:13.000Z","updated":"2021-04-03T12:47:19.582Z","comments":true,"path":"2021/04/02/手撕算法——查找/","link":"","permalink":"http://example.com/2021/04/02/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/","excerpt":"","text":"顺序查找适合存储结构为顺序存储或这链接存储的线性表 思路顺序查找从第一个元素开始查找，不论要查找的列表有序无序，将扫描到的值和关键字比较，相等则成功；否则查找失败，则不成功 代码123456789public static int sequenceSearch(int[] array, int k) &#123; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == k) return i; &#125; return -1; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"查找","permalink":"http://example.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-04-02T08:17:44.819Z","updated":"2021-04-02T08:17:44.819Z","comments":true,"path":"2021/04/02/hello-world/","link":"","permalink":"http://example.com/2021/04/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"随记","slug":"随记","permalink":"http://example.com/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"计算机知识点","slug":"计算机知识点","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"计算机知识","slug":"计算机知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"},{"name":"Java原理","slug":"Java原理","permalink":"http://example.com/categories/Java%E5%8E%9F%E7%90%86/"},{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://example.com/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"数据库知识点","slug":"数据库知识点","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"},{"name":"粤语歌","slug":"粤语歌","permalink":"http://example.com/tags/%E7%B2%A4%E8%AF%AD%E6%AD%8C/"},{"name":"陈奕迅","slug":"陈奕迅","permalink":"http://example.com/tags/%E9%99%88%E5%A5%95%E8%BF%85/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"查找","permalink":"http://example.com/tags/%E6%9F%A5%E6%89%BE/"}]}
{"meta":{"title":"07♥的主页","subtitle":"","description":"","author":"lqx","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"LeetCode手撕——二分查找69/34","slug":"LeetCode手撕——二分查找69-34","date":"2021-07-04T14:14:30.000Z","updated":"2021-07-04T14:14:30.566Z","comments":true,"path":"2021/07/04/LeetCode手撕——二分查找69-34/","link":"","permalink":"http://example.com/2021/07/04/LeetCode%E6%89%8B%E6%92%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE69-34/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Web安全测试","slug":"Web安全测试","date":"2021-07-04T14:09:24.000Z","updated":"2021-07-04T14:12:25.242Z","comments":true,"path":"2021/07/04/Web安全测试/","link":"","permalink":"http://example.com/2021/07/04/Web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/","excerpt":"","text":".html一般为静态页面php经过服务器中的语言解释器，解释执行成html页面目前web服务器端由web服务器+语言解释器+数据库组成 目前流行的Web服务器架构（Web服务+解释执行环境+数据库） Windows server：IIS+ASP(.NET)+SQL Server → .NET环境 Linux：Apache+PHP+MySQL → LAMP环境 UNIX/Windows：Tomcat+JSP+Oracle → J2EE环境 Web安全常用的安全问题：钓鱼——发送伪造的链接、篡改——攻破对方网站进行网页篡改、暗链(使用最多)——植入第三方链接、WebShell——攻破服务器并可以随时进入 web安全的具体分类： 客户端安全——XSSCross Site Script——跨站脚本用于盗取用户信息、钓鱼、制造蠕虫 通过Html注入，篡改网页，插入恶意脚本，当用户在浏览网页时，实现控制用户浏览器行为的一种攻击方式 黑客使用cookie，以用户身份访问 XSS 一般黑客故意设置图片加载失败等方法，触发onerror事件，导致触发xss 存储型：访问网站触发XSS弹窗，该携带XSS的网页脚本存储到数据库中 反射型：用户点击携带xss的脚本链接 DOM型： CSRF漏洞 利用用户已经登录的身份，在用户不知情的情况下，用用户的名义完成非法操作","categories":[],"tags":[]},{"title":"LeetCode——二分查找81","slug":"LeetCode——二分查找81","date":"2021-07-04T14:08:19.000Z","updated":"2021-07-04T14:08:58.314Z","comments":true,"path":"2021/07/04/LeetCode——二分查找81/","link":"","permalink":"http://example.com/2021/07/04/LeetCode%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE81/","excerpt":"","text":"81.搜索旋转排序数组 II 思路 说实话题目刚开始我没看明白，他要干啥，数是否存在与数组中从头遍历不就好了；但是效率要高，所以使用二分法，但是二分法的前提条件是已经排序好的序列，这道题应该是为了练习两段二分法而编的毫无道理的一道题既然来了，就两段二分，最后返回值||就好了 代码 1234567891011121314151617181920212223242526public static boolean search(int[] nums, int target) &#123; &#x2F;&#x2F;1.找到旋转点，进行二分 int mid&#x3D;0; for(int i&#x3D;1; i&lt;nums.length; i++)&#123; if(nums[i-1]&gt;nums[i])&#123; mid&#x3D;i-1; &#125; &#125; &#x2F;&#x2F;2.两段二分法 return binary(nums,0,mid,target) || binary(nums, mid+1, nums.length-1, target); &#125; public static boolean binary(int[] nums, int left, int right, int target)&#123; while(left&lt;&#x3D;right)&#123; int mid &#x3D; (left+right)&#x2F;2; if(nums[mid]&lt;target)&#123; left &#x3D; mid+1; &#125;else if(nums[mid]&gt;target)&#123; right &#x3D; mid-1; &#125;else&#123; return true; &#125; &#125; return false; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode——二分查找540","slug":"LeetCode——二分查找540","date":"2021-07-04T14:05:35.000Z","updated":"2021-07-04T14:07:39.904Z","comments":true,"path":"2021/07/04/LeetCode——二分查找540/","link":"","permalink":"http://example.com/2021/07/04/LeetCode%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE540/","excerpt":"","text":"540.有序数组中的单一元素 思路 咋说呢，这道题完全没有思路，没想到怎么从找到单一元素转换到二分法查找；看了一下题解，说是看出现单一元素的左右两侧奇偶位置的变化，还是没明白…..最后看了一下官方题解，按照官方来一遍： 本题目的重点就是左右指针要怎么走，没有和mid比较大小了，因为根本就没有用来比较的target；可以发现的规律是，当删除和mid相同的一对时，必定还剩下奇数和偶数的两个数组，单一元素出现的位置肯定是在奇数的数组里，这样就又回到了二分法的套路——缩小搜索范围 所以具体和mid相等的值在其左侧还是右侧要分别考虑；并且不同的奇数区间在左侧还是右侧，left和right的指针变动情况都不相同，如下： 当删除mid和mid+1，并且right-mid为偶数时，left=mid+2/41.png 当删除mid和mid+1，并且right-mid为奇数时，right=mid-1/42.png 当删除mid和mid-1，并且right-mid为偶数时，right=mid-2/43.png 当删除mid和mid-1，并且right-mid为奇数时，left=mid+1/44.png 当没有找到和mid相等的值，说明此时mid对应的就是单一的元素；当跳出当前while循环时，此时right=left并且指向单一元素 代码 123456789101112131415161718192021222324252627282930313233public static int singleNonDuplicate(int[] nums) &#123; int left &#x3D; 0; int right &#x3D; nums.length-1; while(left&lt;right)&#123; int mid &#x3D; (left+right)&#x2F;2; &#x2F;&#x2F;相等值在右边 if(nums[mid+1]&#x3D;&#x3D;nums[mid])&#123; &#x2F;&#x2F;1.单个元素在右区间 if((right-mid)%2&#x3D;&#x3D;0)&#123; left&#x3D;mid+2; &#125; else&#123; right&#x3D;mid-1; &#125; &#125; &#x2F;&#x2F;与mid相等的值在左边 else if(nums[mid-1]&#x3D;&#x3D;nums[mid])&#123; &#x2F;&#x2F;1.单个元素在右区间 if((right-mid)%2!&#x3D;0)&#123; left&#x3D;mid+1; &#125; else&#123; right&#x3D;mid-2; &#125; &#125; &#x2F;&#x2F;没有和mid相等的情况 else&#123; return nums[mid]; &#125; &#125; &#x2F;&#x2F;当左右指针合并 return nums[left]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"随记三","slug":"随记三","date":"2021-04-23T13:10:32.000Z","updated":"2021-04-24T08:01:42.454Z","comments":true,"path":"2021/04/23/随记三/","link":"","permalink":"http://example.com/2021/04/23/%E9%9A%8F%E8%AE%B0%E4%B8%89/","excerpt":"","text":"今天下午5.00经历了人生第一场测试开发岗的面试，哈哈哈哈说实话还是有点紧张的q(≧▽≦q) 今天找面试的位置就找了好久，刚开始搬到了电梯口附近，结果又是搬桌子，又是搬椅子，好不容易累的满头大汗，结果插座没电…我tm……… !()[3.gif] 后来好不容易搬到了五楼的角落，呆了一会，管理大妈说这不能学习，不能连安全出口只是盘的插座 !()[3.gif]","categories":[{"name":"随记","slug":"随记","permalink":"http://example.com/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://example.com/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"数据结构——顺序查找","slug":"数据结构——顺序查找","date":"2021-04-22T14:55:39.000Z","updated":"2021-04-22T14:56:17.691Z","comments":true,"path":"2021/04/22/数据结构——顺序查找/","link":"","permalink":"http://example.com/2021/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/","excerpt":"","text":"适合存储结构为顺序存储或这链接存储的线性表 思路顺序查找从第一个元素开始查找，不论要查找的列表有序无序，将扫描到的值和关键字比较，相等则成功；否则查找失败，则不成功 代码1234567public static int sequenceSearch(int[] array, int k) &#123; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == k) return i; &#125; return -1; &#125; 复杂度时间复杂度：O(n)空间复杂度：O(1) 折半（二分）查找思路折半查找必须要求待查找的列表要先进行排序，确保有序后，将要查找的k值与中间的值进行比较（没有中间值的话，就和中间位置的前一个值进行比较）；如果找到则退出方法，否则根据比较的大小值决定和左侧或者右侧的列表的中间值进行比较，递归进行上述步骤，知道找到或者找不到返回-1 代码(自己写的)12345678910111213141516public static int binarySearch(int[] array,int k,int arr1,int arr2) &#123; int mid=array[(arr2-arr1)/2];//获得中间值 if(k==array[mid]) return mid; else&#123; if(k&lt;array[mid]) &#123; binarySearch(array,k,0,mid-1); &#125; else if(k&gt;array[mid]) &#123; binarySearch(array,k,mid+1,arr2); &#125; &#125; &#125; 存在的问题1.这样用arr1,arr2计算得到的mid位置是基于整体的array数组中的位置，而不是左或者右边的位置，递归得到的结果是错误的； 改进： 1int mid&#x3D;array[(arr2+arr1)&#x2F;2];&#x2F;&#x2F;+也能计算中间值的位置 2.上述代码会报错，并没有考虑在扫描完整个的列表后，没有找到匹配值的情况； 改进：可以增加while循环判断，当递归传入的值有前面的位置坐标反而比后面的大的情况（或者是后面的位置坐标比前面的小），这样的话就表示没有找到这个k值，作为递归的出口； 改进后代码123456789101112131415161718192021public static int binarySearch(int[] array,int k,int arr1,int arr2) &#123; int mid&#x3D;(arr2+arr1)&#x2F;2;&#x2F;&#x2F;获得中间值 while(arr2&gt;&#x3D;(mid)&amp;arr1&lt;&#x3D;(mid)) &#123; if(k&#x3D;&#x3D;array[mid]) return mid; else&#123; if(k&lt;array[mid]) &#123; binarySearch(array,k,0,mid); &#125; else if(k&gt;array[mid]) &#123; binarySearch(array,k,mid+1,arr2); &#125; &#125; &#125; return -1; &#125; 存在的问题1.首先调用递归两个binarySearch(~)根本没有return，就相当于每次没有返回出口 2.递归虽然代码简单，但是效率不高 改进后代码123456789101112131415161718public static int binarySearch(int[] arr,int data)&#123; int low&#x3D;0; int high&#x3D;arr.length-1; while(low&lt;&#x3D;high) &#123; int mid&#x3D;(low+high)&#x2F;2; if(arr[mid]&lt;data) low&#x3D;mid+1; else if(arr[mid]&#x3D;&#x3D;data) return mid; else high&#x3D;mid-1; &#125; return -1;&#x2F;&#x2F;找不到 &#125; 1.二分查找对于重复数据找到的位置并不确定，有可能找到的第一个出现的该数据，有可能找到的是最后一个出现的该数据 2.二分查找的缺陷就是要依赖有序的数组 3.数组对于查询方便，但是对于增加删除等对后续有很大的影响；并且数组限制长度，不能灵活扩容 4.二分查找的时间复杂度O(logN)","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"List接口-01","slug":"List接口-01","date":"2021-04-22T14:53:12.000Z","updated":"2021-04-22T14:53:37.975Z","comments":true,"path":"2021/04/22/List接口-01/","link":"","permalink":"http://example.com/2021/04/22/List%E6%8E%A5%E5%8F%A3-01/","excerpt":"","text":"List特点1.List是Collection接口的子接口 2.List集合中元素有序，元素可以重复，按照存放的顺序来取出元素 3.List接口中的每一个元素都有其对应的顺序索引，也就是List的底层为数组 1list.get(index);&#x2F;&#x2F;也就是支持get(index)通过索引获取数据index从0开始 4.Java API中实现List接口的类很多：Vector、ArrayList、LinkedList、Stack… List常用方法1.指定位置插入元素，返回是否成功 1boolean add(int index,Object ele); 当不指定index时，默认插入到List的末尾 1boolean add(Object ele); 2.指定位置插入集合元素 1boolean addAll(int index,Collection eles); 3.获取指定位置元素 1Object get(int index); 4.返回obj在集合中首次出现的位置 1int indexOf(Object obj); 5.返回obj在集合中最后一次出现的位置 1int lastIndexOf(Object obj); 6.移除指定的元素，并返回boolean类型 1boolean remove(Object o); 7.替换某位置的元素为另一个值:当没有这个index时，控制台报错：IndexOutOfBoundException 1Object set(int index, Object ele); 8.返回从fromIndex到toIndex的集合 1List subList(int fromIndex,int toIndex); 但是实际返回的集合是下标[fromIndex,toIndex-1]!!! List常用遍历方法iterator模式增强for模式ArrayListArrayList允许存放null，并且可以存放多个null值 ArrayList底层为数组实现的，但是ArrayList线程不安全，没有synchronied关键字","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java Collections","slug":"Java-Collections","permalink":"http://example.com/tags/Java-Collections/"}]},{"title":"Set接口-01","slug":"Set接口-01","date":"2021-04-22T14:51:56.000Z","updated":"2021-04-22T14:52:29.066Z","comments":true,"path":"2021/04/22/Set接口-01/","link":"","permalink":"http://example.com/2021/04/22/Set%E6%8E%A5%E5%8F%A3-01/","excerpt":"","text":"Set接口特点1.Set接口无序，也就是添加和取出的顺序是不同的，并且没有索引；有可能每次运行add添加进Set后，显示的顺序都是不同的（但是取出的顺序是一致的，就是每次不会改变取出的顺序） 2.Set不可以有重复数据，最多一个null 3.Set因为是继承了Collection接口，所以也可以使用Collection的方法；Set可以使用迭代器，增强for循环来遍历，但是不能使用索引的方法","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java Collections","slug":"Java-Collections","permalink":"http://example.com/tags/Java-Collections/"}]},{"title":"Set接口-02","slug":"Set接口-02","date":"2021-04-22T14:50:27.000Z","updated":"2021-04-22T14:51:23.944Z","comments":true,"path":"2021/04/22/Set接口-02/","link":"","permalink":"http://example.com/2021/04/22/Set%E6%8E%A5%E5%8F%A3-02/","excerpt":"","text":"HashSet说明1.HashSet的底层是HashMap 123public HashSet()&#123; map &#x3D; new HashMap&lt;&gt;();&#125; 2.HashSet可以存放null,但是只能存放一个null；也就说明元素不可以重复 3.HashSet不保证存放的元素是有序的，取决于hash后，再确定的索引结果，也就是存放和取出的顺序不一致 4.对于Collection接口中的方法都可以使用！！！ 5.针对重复元素的创建： 12345678910set.add(&quot;join&quot;);set.add(&quot;join&quot;);&#x2F;&#x2F;两者在常量池中的内存地址相同set.add(new Dog(&quot;tom&quot;));set.add(new Dog(&quot;tom&quot;));&#x2F;&#x2F;两者名字相同，但是对应的内存地址不同set.add(new String(&quot;tom&quot;));set.add(new String(&quot;tom&quot;));&#x2F;&#x2F;此时第二个tom不能够添加成功，根据hashCode()和equals()判断添加可知（见equals和hashCode()区分——博客） 测试代码： 123456789101112HashSet set&#x3D; new HashSet(); System.out.println(set.add(&quot;lingqixin&quot;)); set.add(&quot;feichenyaya&quot;); set.add(new String(&quot;dog&quot;)); set.add(new String(&quot;dog&quot;)); set.add(new Dog(&quot;ji&quot;)); set.add(new Dog(&quot;ji&quot;)); for(Object o:set) &#123; System.out.println(set); &#125; 测试输出值： 12345[Dog@28d93b30, lingqixin, Dog@1b6d3586, dog, feichenyaya][Dog@28d93b30, lingqixin, Dog@1b6d3586, dog, feichenyaya][Dog@28d93b30, lingqixin, Dog@1b6d3586, dog, feichenyaya][Dog@28d93b30, lingqixin, Dog@1b6d3586, dog, feichenyaya][Dog@28d93b30, lingqixin, Dog@1b6d3586, dog, feichenyaya] HashSet底层机制HashSet的底层是HashMap，并且HashMap的底层为数组+链表+红黑树 也就是当链表长度到达了数组中数值要求的长度后，就会将链表完成树化，变成一个红黑树 HashSet的扩容机制基本和String new()机制相同，首先获取hash值，然后调用equals进行比较，在JDK8中，如果一条链表的元素个数到达了TREEIFY_THRESHOLD(默认为8)，并且table数组的大小&gt;=MIN-TREEIFY(默认为64)就会转化成红黑树 如果只是到达8，但是64没有达到，这是会将table表进行扩容","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java Collections","slug":"Java-Collections","permalink":"http://example.com/tags/Java-Collections/"}]},{"title":"笔试习题","slug":"笔试习题","date":"2021-04-22T14:48:49.000Z","updated":"2021-04-22T14:49:11.217Z","comments":true,"path":"2021/04/22/笔试习题/","link":"","permalink":"http://example.com/2021/04/22/%E7%AC%94%E8%AF%95%E4%B9%A0%E9%A2%98/","excerpt":"","text":"代码求值1.假定x=9999,统计1的个数： 1234567891011int func(int x)&#123; int countx &#x3D; 0; while(x) &#123; countx++; x &#x3D; x&amp;(x-1);&#x2F;&#x2F;每执行一次将x的最右边的1变成0 &#125; return countx;&#125; 解：9999B=10011100001111每执行减少一个1，所以1的个数为答案 2. 123#define ADD(x,y) x+yint m&#x3D;3;m+&#x3D;m*ADD(m,m); 解： 程序解读1. 123456ftell(fp); &#x2F;&#x2F;用于得到文件位置指针当前位置相对文件首部的偏移字节数fseek(fp,0,SEEK_END); &#x2F;&#x2F;将文件指针fp定位到文件尾int fseek(FILE *stream, long offset, int fromwhere); &#x2F;&#x2F;函数fseek将文件位置指针重定位到fromwhere（SEEK_SET文件头0,SEEK_CUR文件当前位置1,SEEK_END文件末尾2）开始偏移offset个字节的位置；返回成功0，失败-1； 计算机常识1.文本加密： RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的，非对称算法；RC2和RC4：对称算法，用变长密钥对大量数据进行加密，比 DES 快；DES（Data Encryption Standard）：对称算法，数据加密标准，速度较快，适用于加密大量数据的场合；MD5：严格来说不算加密算法，只能说是摘要算法； C/C++基础1.什么东西能在类内初始化？ 能在类中初始化的成员只有一种，那就是静态常量成员： 1234567891011121314151617181920这样不行 class A &#123; private: static int count &#x3D; 0; &#x2F;&#x2F;静态成员不能在类内初始化 &#125;;这样也不行 class A &#123; private: const int count &#x3D; 0; &#x2F;&#x2F;常量成员也不能在类内初始化 &#125;;但是这样可以 class A &#123; private: static const int count &#x3D; 0; &#x2F;&#x2F;静态整型常量成员可以在类内初始化，但是 static const float count就不行了 &#125;; 2.C++中运算符重载是多态性的一种表现运算符重载是针对C++原有运算符进行的，不可能通过重载创造出新的运算符除了. （成员访问运算符）.* （成员指针访问运算符）:: （域运算符）sizeof （长度运算符）?: （条件运算符）这5个运算符外，其他运算符都可以重载 运算符重载不可改变其结合性，操作数个数和优先级 3.一个由C/C++编译的程序占用的内存分为以下几个部分: 动态内存分配: 栈区(stack) 由编译器自动分配释放，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈; 堆区(heap)一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表:new、 malloc 、free、delete等 全局区(静态区) (static)存放全局变量、静态数据、常量。程序结束后由系统释放 文字常量区常量字符串就是放在这里的。程序结束后由系统释放 程序代码区存放函数体(类成员函数和全局函数) 的二进制代码。 4.什么样的函数不能声明为虚函数？ 不能被继承的函数不能被重写的函数 1）普通函数 普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数 而多态体现在运行时绑定。通常通过基类指针指向子类对象实现多态 2）友元函数 友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。 3）构造函数 首先说下什么是构造函数，构造函数是用来初始化对象的。假如子类可以继承基类构造函数，那么子类对象的构造将使用基类的构造函数，而基类构造函数并不知道子类的有什么成员，显然是不符合语义的。从另外一个角度来讲，多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。因此构造函数不允许继承。 4）内联成员函数 我们需要知道内联函数就是为了在代码中直接展开，减少函数调用花费的代价。也就是说内联函数是在编译时展开的。而虚函数是为了实现多态，是在运行时绑定的。因此显然内联函数和多态的特性相违背。 5）静态成员函数 首先静态成员函数理论是可继承的。但是静态成员函数是编译时确定的，无法动态绑定，不支持多态，因此不能被重写，也就不能被声明为虚函数。 Java基础1.int 是八大基本数据类型之一（byte,char,short,int,long,float,double,boolean）Integer 是 int 包装类;int是基本数据类型，默认值为0,Integer 是类，默认值为null；Integer 表示的是对象，用一个引用指向这个对象,int是基本数据类型，直接存储数值 2.Java构造函数，函数名和类名相同，没有返回值，包括void!!!!! 3. 12345678910111213141516public class B&#123; public static B t1 &#x3D; new B(); public static B t2 &#x3D; new B(); &#123; System.out.println(&quot;构造块&quot;); &#125; static &#123; System.out.println(&quot;静态块&quot;); &#125; public static void main(String[] args) &#123; B t &#x3D; new B(); &#125;&#125;","categories":[],"tags":[{"name":"笔试习题","slug":"笔试习题","permalink":"http://example.com/tags/%E7%AC%94%E8%AF%95%E4%B9%A0%E9%A2%98/"}]},{"title":"LeetCode手撕——字符串","slug":"LeetCode手撕——字符串","date":"2021-04-22T14:46:27.000Z","updated":"2021-04-22T14:48:17.762Z","comments":true,"path":"2021/04/22/LeetCode手撕——字符串/","link":"","permalink":"http://example.com/2021/04/22/LeetCode%E6%89%8B%E6%92%95%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"获取最长无重复字符的子串12345678910111213141516171819202122232425class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Set&lt;Character&gt; occ &#x3D; new HashSet&lt;Character&gt;(); int n&#x3D;s.length(); int rk&#x3D;-1,ans&#x3D;0; &#x2F;&#x2F;rk表示的是后面的指针 for(int i&#x3D;0;i&lt;n;i++)&#x2F;&#x2F;i代表头指针 &#123; if(i!&#x3D;0) &#123; occ.remove(s.charAt(i-1)); &#125; while(rk+1&lt;n&amp;&amp;!occ.contains(s.charAt(rk+1)))&#123;&#x2F;&#x2F;保证左指针不超过长度，并且哈希表中不包含下一个字符，也就是没有重复字符 occ.add(s.charAt(rk+1));&#x2F;&#x2F;将该字符放入到哈希表中 ++rk; &#125; ans&#x3D;Math.max(ans,rk-i+1);&#x2F;&#x2F;获取所有不含重复子串的最长的子串 &#125; return ans; &#125;&#125; 求最长回文子串123456789101112131415161718192021222324252627282930class Solution &#123; public String longestPalindrome(String s) &#123; String res&#x3D;&quot;&quot;; int start&#x3D;0,end&#x3D;0; for(int i&#x3D;0;i&lt;s.length();i++)&#123;&#x2F;&#x2F;每次循环都将该位置的字符作为回文的中心字符，分奇偶两种情况进行讨论 &#x2F;&#x2F;回文串为奇数，从一个中心点扩展 String s1&#x3D;expandAroundCenter(s,i,i); &#x2F;&#x2F;回文串为偶数，从两个中心点扩展 String s2&#x3D;expandAroundCenter(s,i,i+1); res&#x3D;res.length()&gt;s1.length()?res:s1; res&#x3D;res.length()&gt;s2.length()?res:s2; &#125; return res; &#125; public String expandAroundCenter(String s,int left,int right)&#123; while(left&gt;&#x3D;0&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)&#x3D;&#x3D;s.charAt(right)) &#123; left--; right++; &#125; &#x2F;&#x2F;从中心开始扩展，左右两侧的指针没有越界并且值相同，就可以往外扩展 return s.substring(left+1,right);&#x2F;&#x2F;返回当前字符为中心点的最长回文串 &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"数据结构——树","slug":"数据结构——树","date":"2021-04-22T14:38:03.000Z","updated":"2021-04-22T14:43:44.140Z","comments":true,"path":"2021/04/22/数据结构——树/","link":"","permalink":"http://example.com/2021/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/","excerpt":"","text":"二叉树（BST、AVL） 二叉搜索（排序）树BST：若左子树不为空，则左子树上的所有节点的值均小于他的根节点的值；如果他的右子树不为空，则右子树山的所有节点值均大于它的根节点值，时间复杂度为O(logn) 二叉搜索树的缺陷，输入数据为递增或 递减时当退化成链表的时候效率变成了O(n) 那么如何避免上面2的这种缺陷呢？如果插入元素时，树可以自动调整使得两边平衡——平衡二叉树AVL 依靠左旋或右旋的方法让树平衡，AVL约定最短和最长子树高度差不能超过1， AVL树通过插入性能的损失来弥补查询性能的提升 那么如何避免在插入远大于查找过程中的性能损失呢——引入红黑树 红黑树红黑树属于二叉搜索树的一个分支，也借鉴了AVL树中左右旋的方法 红黑树根节点一定是黑色 每个叶子节点为黑色（NIL节点） 每个红色节点的两个子节点为黑色，也就是不存在两个红色的节点相连 任意一个节点到每个叶子节点的路径都包含数量相同的黑节点——黑高 最长子树不超过最短子树的两倍即可 构造红黑树——左旋、右旋、变色图片./blog/img/4.png 1.左旋 图片./blog/img/5.gif 2.右旋 图片./blog/img/7.gif 红黑树的插入插入后要对两边进行平衡调整，默认带插入的节点都是红色的 1.当红黑树为空树： 直接将节点插入作为根节点，并且根据性质2，要将节点设置为黑色，NIL节点为黑色 2.要插入的节点在树中已经存在，直接替换值就可以 3.插入节点的父节点为黑色节点，直接按照正常排序二叉树的插入就可以 4.插入节点的父节点为红色节点，那么就说明当前的节点一定存在一个根节点为黑色的： 将该节点的父亲和叔叔节点该为黑色，爷爷节点改为红色，爷爷节点作为当前节点进行后续处理图片./blog/img/8.jpg 当叔叔节点不存在或者为NIL黑色节点，并且插入节点的父亲节点为爷爷的左子节点，此时要分情况讨论：图片./blog/img/9.jpg （1）当要插入的节点在父亲节点的左边时——LL双红——右旋 将父亲节点变成黑色，爷爷节点变成红色；对爷爷节点进行右旋 图片./blog/img/10.jpg 但是随着插入的数据变多不可避免地因为每棵树只有两个子树导致树的深度变大——B树 B树Max Degree:表示每个节点可以放的最大记录（表示达到degree值后就要进行拆分） B树中允许有相同值的存储，相同的值放在要插入的节点右侧 具体的存储格式如图：/14.jpg 但是对于&lt;K,V&gt;中Key和Value一同存储就导致了资源的浪费，既然K作为主键值唯一确定V值，只存储K就可以了——B+树 B+树存储结构见图：/15.jpg B+树只有在叶子节点中存储数据，而在非叶子节点中不存储Value的值，只存储Key B+树的叶子节点是一个双向链表 一般情况下MySQL使用的B+树只要是3-4层足够了，如果发现不够，就有可能要进行分表分库存储 Q：创建索引时用int还是varchar?A：因为存储时指针的大小是固定的，之能尽可能的让Key的值尽量少的占用非叶子结点的存储空间，这样就能增加每个节点存储的degree值（记录数），所以如果varchar小于4字节，用varchar；反之用int","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"计算机基本常识","slug":"计算机基本常识","date":"2021-04-22T14:36:17.000Z","updated":"2021-04-22T14:37:04.488Z","comments":true,"path":"2021/04/22/计算机基本常识/","link":"","permalink":"http://example.com/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/","excerpt":"","text":"utf-8和ASCII和Unicode编码区别：ASCII 支持英文 1个字节——最早的127个字符，中国制定了GB2312加入中文 unicode 所有语言 2个字节——将所有语言统一到编码中，但是英文也用unicode浪费空间 UTF-8 所有语言 英文1字节、汉字3字节——节省空间，并且包含ASCII","categories":[],"tags":[{"name":"计算机基本知识","slug":"计算机基本知识","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"}]},{"title":"Spring探究","slug":"Spring探究","date":"2021-04-22T14:34:45.000Z","updated":"2021-04-22T14:35:29.168Z","comments":true,"path":"2021/04/22/Spring探究/","link":"","permalink":"http://example.com/2021/04/22/Spring%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"对Spring理解？Spring就是轻量级、非入侵式的Java开发框架，简化企业级服务器的开发，几乎所有的开发都是依靠Spring为基础的，Spring的容器作用用来承载Java中的bean对象； Spring以interface21为基础 Spring帮助我们完成了bean对象从创建，使用到销毁的管理全过程，这个过程可以通过配置文件或者是注解的方式来完成 程序启动后，完成bean的解析和创建以及实例化操作，这里可以通过反射的方式来进行实例化，方便后续直接使用bean Spring中最重要的特点就是**IOC(控制反转)、AOP(面向切面编程)**，并且支持事务处理 框架发展SSH:Struct2+Spring+HibernateSSM:SpringMVC+Spring+Mybatis Spring——官网Spring Maven——官网依赖远程包仓库xml地址例如5.3.4版本的Maven 123456&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt; &lt;version&gt;5.3.4&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; Spring的七大组成/图片1.png Spring Boot：一个快速开发的脚手架，基于SpringBoot可以快速开发一个微服务 Spring Cloud:基于Spring Boot实现 IOC和AOP两个重要的观点 控制反转IOC 通过xml或者是注解通过第三方去生产或者获取对象，在Spring中实现控制反转的是IOC容器，实现的方法是DI(依赖注入) 控制：传统使用程序本身控制对象的创建，使用Spring后，对象是由Spring来创建的 反转：程序本身不创建对象，而变成被动接收对象 依赖注入：依靠Set()方法来注入","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"}]},{"title":"List接口-03","slug":"List接口-03","date":"2021-04-22T14:25:03.000Z","updated":"2021-04-22T14:33:59.099Z","comments":true,"path":"2021/04/22/List接口-03/","link":"","permalink":"http://example.com/2021/04/22/List%E6%8E%A5%E5%8F%A3-03/","excerpt":"","text":"LinkedList底层机制 LinkedList底层实现了双向链表和双端队列的数据结构 底层双向链表首尾节点分别由Node first和Node last来指向，每个Node节点又包含prev、next、item三个属性 基于双向链表的特点，LinkedList的添加和删除效率更高 LinkedList添加元素可以重复，包括多个null LinkedList线程不安全 LinkedList源码","categories":[{"name":"Java API","slug":"Java-API","permalink":"http://example.com/categories/Java-API/"}],"tags":[{"name":"Java Collections","slug":"Java-Collections","permalink":"http://example.com/tags/Java-Collections/"}]},{"title":"LeetCode手撕——栈","slug":"LeetCode手撕——栈","date":"2021-04-22T14:23:39.000Z","updated":"2021-04-22T14:24:16.723Z","comments":true,"path":"2021/04/22/LeetCode手撕——栈/","link":"","permalink":"http://example.com/2021/04/22/LeetCode%E6%89%8B%E6%92%95%E2%80%94%E2%80%94%E6%A0%88/","excerpt":"","text":"每日温度题目 请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用0来代替。 例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是[1, 1, 4, 2, 1, 1, 0, 0] 初步思路 暴力遍历： 针对每天的温度，向后遍历数组，发现超过今天的温度则返回要等待的天数 123456789101112131415161718192021class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int[] result&#x3D;new int[T.length]; for(int i&#x3D;0;i&lt;T.length;i++) &#123; int temp&#x3D;T[i]; int count&#x3D;0; for(int j&#x3D;i+1;j&lt;T.length;j++) &#123; if(temp&lt;T[j]) &#123; count&#x3D;j-i; break; &#125; &#125; result[i]&#x3D;count; &#125; return result; &#125;&#125; 复杂度： 执行用时：958 ms, 在所有 Java 提交中击败了19.47%的用户内存消耗：46.8 MB, 在所有 Java 提交中击败了27.84%的用户 单调栈 每次从T[i]中读出的数据后，首先判断比较栈中的栈顶元素是否比该温度小，小的话就找到了栈顶元素的第一个更高温度天数，count=i-preIndex；否则就继续压栈，直到再次找到更大的入栈元素或者T[]遍历完成栈内所有元素弹出 123456789101112131415public int[] dailyTemperatures(int[] T) &#123; Deque&lt;Integer&gt; stack &#x3D; new LinkedList&lt;Integer&gt;(); int[] result &#x3D; new int[T.length]; &#x2F;&#x2F;该栈存储的是编号而不是温度值 for (int i &#x3D; 0; i &lt; T.length; i++)&#123; while(!stack.isEmpty()&amp;&amp;T[i]&gt;T[stack.peek()])&#123; int preIndex&#x3D;stack.pop();&#x2F;&#x2F;移除第一个元素 result[preIndex]&#x3D;i-preIndex; &#125;&#x2F;&#x2F;循环为了将小于该温度的都找出来 stack.push(i);&#x2F;&#x2F;向头部压入元素 &#125; return result; &#125; 复杂度 时间复杂度：O(n)，只针对for一层循环空间复杂度：O(n)，涉及栈空间的开辟 实现API 利用了Java API中定义的Deque接口，使用LinkedList类作为具体的实现，这里并没有将Deque作为双向队列使用，而只是作为栈来使用 字符串解码题目 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数 初步思路 根据提供的栈的思路，想到了数据结构中表达式的求值，也是两个栈来解答，分别用数字栈存放数字，用字符栈来存放字符；遇到”[“正常存入，遇到”]”弹出字符串直到再次遇到”[“,弹出一个数字进行求值，得到的结果再次压入字符栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public String decodeString(String s) &#123; Stack&lt;Integer&gt; num&#x3D;new Stack&lt;Integer&gt;(); Stack&lt;Character&gt; str&#x3D;new Stack&lt;Character&gt;(); String result&#x3D;&quot;&quot;; String mid_result&#x3D;&quot;&quot;; char[] ch&#x3D;s.toCharArray(); for (char c : ch) &#123; if(&#39;0&#39;&lt;&#x3D;c&amp;&amp;c&lt;&#x3D;&#39;9&#39;)&#123; &#x2F;&#x2F;入数字栈 num.push((int)c-48); &#125; else if(c&#x3D;&#x3D;&#39;[&#39;)&#123; str.push(c); &#125; else if(c&#x3D;&#x3D;&#39;]&#39;)&#123; String mid&#x3D;&quot;&quot;; while(str.peek()!&#x3D;&#39;[&#39;)&#123; mid+&#x3D;str.pop(); &#125; str.pop(); &#x2F;&#x2F;将[出栈 &#x2F;&#x2F;字符串反转,并再次入栈 char[] midch&#x3D;mid.toCharArray(); int i&#x3D;num.pop(); while(i!&#x3D;0)&#123; for(int j&#x3D;midch.length-1;j&gt;&#x3D;0;j--) &#123; str.push(midch[j]); &#125; i--; &#125; &#125; else&#123; str.push(c); &#125; &#125; String stt&#x3D;&quot;&quot;; while(!str.empty())&#123; stt+&#x3D;str.pop(); &#125; &#x2F;&#x2F;再次反转得到结果 char[] res&#x3D;new char[stt.length()]; res&#x3D;stt.toCharArray(); for(int j&#x3D;stt.length()-1;j&gt;&#x3D;0;j--)&#123; result+&#x3D;res[j]; &#125; return result; &#125; 存在的问题 这里面只是考虑到数字为个位数的情况，但是当为超过个位数时，弹出的数值就不正确了，接下来继续优化；","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"Java集合——Deque","slug":"Java集合——Deque","date":"2021-04-22T14:22:22.000Z","updated":"2021-04-22T14:23:02.227Z","comments":true,"path":"2021/04/22/Java集合——Deque/","link":"","permalink":"http://example.com/2021/04/22/Java%E9%9B%86%E5%90%88%E2%80%94%E2%80%94Deque/","excerpt":"","text":"Deque接口Deque表示的是双向队列，就是可以从队列的两端增加或者删除元素 Deque为接口，那么初始化的时候就要用到具体的实现，在Collections API中包含两种实现方式： **- java.util.LinkedList java.util.ArrayDeque** LinkedList实现Deque 创建Deque 123Deque deque &#x3D; new LinkedList();&#x2F;&#x2F;创建Deque对象Deque&lt;Object&gt; deque &#x3D; new LinkedList&lt;Object&gt;();&#x2F;&#x2F;Deque泛型，并且必须是Object类型，不可以是八大基本数据类型 向Deque中添加元素 1234567891011deque.add();&#x2F;&#x2F;向Deque尾部添加元素，不能添加返回error，而不是falsedeque.addLast();&#x2F;&#x2F;同上deque.addFirst();&#x2F;&#x2F;在Deque的头部添加元素deque.offer();&#x2F;&#x2F;在Deque尾部添加元素，成功返回true，失败返回false，而不报错deque.offerFirst();&#x2F;&#x2F;在Deque头部添加元素deque.push();&#x2F;&#x2F;在Deque头部添加元素，失败返回异常 查看Deque中元素 123456789deque.peek();&#x2F;&#x2F;返回第一个元素，为空则返回nulldeque.peekFirst();&#x2F;&#x2F;同上deque.peekLast();&#x2F;&#x2F;返回最后一个元素的值deque.getFirst();deque.getLast(); 移除Deque中元素 1234567891011121314deque.remove();&#x2F;&#x2F;移除第一个元素并返回该元素的值，但是如果为空则抛出异常而不是nulldeque.removeFirst();&#x2F;&#x2F;同上deque.removeLast();&#x2F;&#x2F;移除最后一个元素，抛出异常deque.poll();&#x2F;&#x2F;移除第一个元素，为空则返回null，而不是抛出异常deque.pollFirst();deque.pollLast();deque.pop();&#x2F;&#x2F;移除第一个元素，为空则抛出异常 检查Deque包含某个元素 1deque.contains();&#x2F;&#x2F;返回true或false 获取Deque的大小 1deque.size();&#x2F;&#x2F;获取deque中元素个数 Deque中的元素遍历获取 遵循集合中的常见方法，iterator()或for的增强循环","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"}]},{"title":"Map接口-01","slug":"Map接口-01","date":"2021-04-22T14:20:36.000Z","updated":"2021-04-22T14:21:59.419Z","comments":true,"path":"2021/04/22/Map接口-01/","link":"","permalink":"http://example.com/2021/04/22/Map%E6%8E%A5%E5%8F%A3-01/","excerpt":"","text":"Map接口介绍Map存放的是K-V的键值对 Map和Collectinon并列存在，以键值对形式保存 Map存放和取出的顺序不一致 Map中key和value可以为任意引用类型，会封装到HashMap$Node对象（实现了Entry接口）中，这个Node对象包含了四个属性 1234final int hash;final K key;V value;Node&lt;K,V&gt; next; 当Key发生重复后，用新的Key值对应的Value替换了之前的Value值 但是Map中的Value值可以重复 Key和Value都可以为null，但是Key只能由一个为null，Value可以有多个为null 通常String来作为Key的值 Key和Value必须是一对一的关系，通过Key找到Value值 EntrySet这里没搞懂( •̀ ω •́ )✧ HashMap不支持线程同步 Map接口常用方法 添加元素 1V put(K key,V value) 根据Key值删除 1V remove(Object key) 根据Key值获取 1V get(Object key) 获取数量 1int size() 判断是否为空 1boolean isEmpty() 清空 1void clear() 看是否包含key和value 1boolean containsKey(Object key) 1boolean containsValue(Object value) Map接口遍历HashMap扩容机制 HashMap在jdk7中底层为数组+链表的形式，而在JDK8中变成了数组+链表+红黑树，每一个&lt;K，V&gt;键值对都是以HashMap$Node来存储，而这里Node是实现了Map接口中的Entry接口（从没想过接口里还有接口） 当数组大小为64并且单个链表节点数达到8时，链表树化 HashSet的扩容同HashMap相同 构造器 1234public HashMap()&#123; this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;&#x2F;&#x2F;执行构造器初始化了一个加载因子，值为0.75&#x2F;&#x2F;HashMap$Node[] table &#x3D; null&#125; put方法 123451.首先使用valueOf(Object obj)将所有传入的Object类型转换成String类型public V put(K key, V value)&#123; return putVal(hash(key), key, value, true);&#125; putVal()方法 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;resize()用于new()16个初始空间 if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) tab[i] &#x3D; newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) e &#x3D; p; else if (p instanceof TreeNode) e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount &#x3D; 0; ; ++binCount) &#123; if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123; p.next &#x3D; newNode(hash, key, value, null); if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) break; p &#x3D; e; &#125; &#125; if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key V oldValue &#x3D; e.value; if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null) e.value &#x3D; value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 初始为16个数组空间，初始临界值threshold=12，当Key对应数组位置null时，放入； 再次添加后，进行Key值的比较（equals(Key)），不相同则新增链表节点，否则替换 HashMap底层为什么要用红黑树而不用AVL(二叉查找树)？红黑树也是AVL的一种，都是很高效的查找算法，但是不同的地方在于不限制每个树的节点只有两个分支，AVL弊端就是当节点过多，使得树越来越高，查找效率越来越低 HashMap缺点 HashMap高度依赖于hash()函数，要是Key是自定义类，就要重写hashcode方法 存入时hashcode()就确定了，比如说key是名字，但是后续名字的改变，还存在这个位置就不正确了 HashMap线程不安全，多个线程进行处理时，容易发生错误","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java Collections","slug":"Java-Collections","permalink":"http://example.com/tags/Java-Collections/"}]},{"title":"Map接口-02","slug":"Map接口-02","date":"2021-04-22T14:19:20.000Z","updated":"2021-04-22T14:20:13.899Z","comments":true,"path":"2021/04/22/Map接口-02/","link":"","permalink":"http://example.com/2021/04/22/Map%E6%8E%A5%E5%8F%A3-02/","excerpt":"","text":"实现类Hashtable介绍 Hashtable类实现了Map接口，继承了Dictionary类 Hashtable支持线程同步 其Key和Value值都不可以为空，否则抛出NullPointerException异常 对于Key值相同的键值对，后者会对前者进行替换（这也是所有Map键值对的特点） Hashtable底层 底层为Hashtable$Entry的数组，初始化大小为11（这里的Entry为Hashtable中的静态内部类，继承自Map.Entry接口）12threshold&#x3D;8&#x3D;11*loadFactor&#x3D;11*0.75&#x2F;&#x2F;临界值，也就是当再次需要扩容时为8个 Hashtable扩容机制：最开始为11个空间，每次添加的键值对达到threshold后，根据threshold*loadFactor获取到下一次扩容时的扩容数量，这两个值可以在Debug下看到","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java Collections","slug":"Java-Collections","permalink":"http://example.com/tags/Java-Collections/"}]},{"title":"Map接口-03","slug":"Map接口-03","date":"2021-04-22T14:17:23.000Z","updated":"2021-04-22T14:19:04.289Z","comments":true,"path":"2021/04/22/Map接口-03/","link":"","permalink":"http://example.com/2021/04/22/Map%E6%8E%A5%E5%8F%A3-03/","excerpt":"","text":"TreeMap源码分析 TreeSet的底层就是TreeMap，当作为TreeSet实现时&lt;K,V&gt;中，V值为PRESENT的静态对象 没有为comparator对象赋值的话，put方法就按照默认的String类中的compareTo()方法来比较Key值的String大小进行排序添加 可以利用内部类中重写CompareTo()方法设置TreeMap中键值对的存储排序顺序 123456789101112TreeMap treeMap &#x3D; new TreeMap(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; return ((String) o2).compareTo((String) o1) ;&#x2F;&#x2F;按照Key的大小进行排序大→小 return ((String)o2).length()-((String)o1).length(); &#125; &#125;); treeMap.put(&quot;lingi&quot;,&quot;凌淇鑫&quot;); treeMap.put(&quot;wang&quot;,&quot;王祖贤&quot;); treeMap.put(&quot;Brader&quot;,&quot;Brad Pitt&quot;); System.out.println(&quot;treeMap&#x3D;&quot;+treeMap); 1234public TreeMap(Comparator&lt;? super K&gt; comparator)&#123; this.comparator&#x3D;comparator;&#125;&#x2F;&#x2F;构造器：把传入的实现了Comparator接口的匿名内部类对象传递给TreeMap的comparator属性 调用put方法时，第一次为Null时添加直接创建Entry对象作为root，第二次之后 启动comparator比较器，用返回值与0比较决定放在tree的left还是right,这里的Key是否相等由程序员决定，而不是像HashMap由equals和HashCode决定 但是上面代码中的例子，比如按照字符串的长度进行排序时，当出现相同长度时，就不会进行put操作 1234567891011121314 TreeMap treeMap &#x3D; new TreeMap(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; &#x2F;&#x2F;return ((String) o2).compareTo((String) o1) ;&#x2F;&#x2F;按照Key的大小进行排序大→小 return ((String)o2).length()-((String)o1).length(); &#125; &#125;); treeMap.put(&quot;ling&quot;,&quot;凌淇鑫&quot;); treeMap.put(&quot;wang&quot;,&quot;王祖贤&quot;); treeMap.put(&quot;Brad&quot;,&quot;Brad Pitt&quot;); &#x2F;&#x2F;这里三个Key的长度都相同，第一个ling作为Key存入后，与之匹配的Value的值&quot;凌淇鑫&quot;存入，但是后续的key值因为重复不会存入，但是值会发生替换&#x2F;&#x2F;最终导致只存放&#123;ling&#x3D;Brad Pitt&#125;一个键值对 put的源码如下 123456789101112if (cpr !&#x3D; null) &#123; do &#123; parent &#x3D; t; cmp &#x3D; cpr.compare(key, t.key); if (cmp &lt; 0) t &#x3D; t.left; else if (cmp &gt; 0) t &#x3D; t.right; else return t.setValue(value);&#x2F;&#x2F;这也解释了为什么要替换值但是Key不保留 &#125; while (t !&#x3D; null); &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"}]},{"title":"Map接口-04","slug":"Map接口-04","date":"2021-04-22T14:15:47.000Z","updated":"2021-04-22T14:16:26.024Z","comments":true,"path":"2021/04/22/Map接口-04/","link":"","permalink":"http://example.com/2021/04/22/Map%E6%8E%A5%E5%8F%A3-04/","excerpt":"","text":"LinkedHashMap特点 LinkedHashMap继承自HashMap，实现了Map接口，不同的LinkedHashMap在底层维护了一个双向链表 LinkedHashMap(int ,float, boolean)这个构造器中，为true时设置为访问的顺序存储，否则默认以put的顺序存储 集合类的选择规范 首先判断对象类型为单例：Collection接口中List、Set&emsp;允许重复：List&emsp;&emsp;增删多：LinkedList(链表)&emsp;&emsp;改查多：ArrayList(数组)&emsp;不允许重复：Set&emsp;&emsp;无序：HashSet(HashMap)&emsp;&emsp;排序：TreeSet&emsp;&emsp;插入和取出的顺序一致：LinkedHashSet&emsp;键值对：Map接口&emsp;无序：HashMap&emsp;排序：TreeMap&emsp;插入和取出的顺序一致：LinkedHashMap&emsp;能够读取文件：Properties Map接口类汇总 类型 底层结构 是否线程同步 扩容机制 存储特点 HashMap 数组+链表+红黑树 否 当数组达到64，链表数达到8就会发生树化 Key只有一个为Null，Value可以多个为null，遍历时获取数据随机 Hashtable Entry类型数组(Hash值存储) 是 初始值11个Entry数组，达到极限值就按照极限值*加载因子进行再次扩容 不允许存储null，遍历获取数随机 TreeMap 红黑树 否 像Comparator参数传值按照特定顺序存储，null可以存一个，默认按照字符串升序存储 LinkedHashMap 数组+双向链表+红黑树 否 输出和输入的顺序相同","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"}]},{"title":"Java线程","slug":"Java线程","date":"2021-04-22T14:14:28.000Z","updated":"2021-04-22T14:16:47.891Z","comments":true,"path":"2021/04/22/Java线程/","link":"","permalink":"http://example.com/2021/04/22/Java%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"线程、进程和协程进程————打开百度网盘就是应用程序的启动实例，就是运行中的程序，比如说打开了软件，打开一个游戏就是开启了一个进程，进程能够拥有代码和打开的文件资源、数据资源、独立的内存空间进程就包含自身的产生、存在和消亡的过程 线程————启动一个下载任务属于进程，线程是进程创建的，线程是进程的一部分，并且拥有自己独立的栈空间；线程是最小执行单元，进程是最小的资源管理单元通常所说的五大状态都是线程所拥有的：初始化，就绪，运行，阻塞，销毁 线程和进程的区别 两者最主要的区别就是操作系统对其不同的资源管理方式 一段程序启动后自动创建了一个进程，进程拥有独立的地址空间 线程可以算作是进程的一部分，线程拥有自己的堆栈空间，多个线程共享内存 进程之间的切换对资源消耗大，而线程之间的切换效率较高，对于要求的并发量大的操作，只能用线程 JVM通过调用os内核中的TCB（线程控制模块）来改变线程的状态，过程耗费CPU资源；并且根据生产者消费者算法（全部生产者线程组成进程），要设置同步锁和线程之间状态的转换，这就很耗费性能； 协程就是轻量级线程线程可以有多个协程，比如在主线程中生产数据，在协程中消费数据，协程暂停完全可以由程序控制，而不需要操作系统内核来切换，开销很小 协程就是减少了线程的切换，速度更快例如python中的yield关键字，是程序强制等待而不是操作系统决定的，这样在内部的分配就不用了上锁和互斥的添加 并发和并行并发：同一时刻，多个任务交替进行，单核CPU实现多任务 并行：同一时刻，多个任务同时执行，多核CPU可以实现并行 并发和并行同时存在 123Runtime runtime &#x3D; Runtime.getRuntime();int cpuNums&#x3D;runtime.availableProcessors();&#x2F;&#x2F;获取此电脑CPU数量 进程调度算法 先来先服务调度算法 短作业优先调度算法不能保证紧迫性进程及时处理 优先级调度算法非抢占式：分配给cpu后，就完全按照优先级调度抢占式：执行期间如果出现了另一个更高优先级的进程，进程调度立即停止 高响应比优先调度算法R=（等待时间+要求服务时间）/要求服务时间好处在于，当等待时间相同时，要求服务时间越小，R越大，有利于短作业优先当要求服务时间相同时，等待时间越大，R越大，有利于先来的先处理 时间片轮转调度算法用完了规定的时间片，但是任务未完成，自行释放占有的CPU，到就绪队列等待 多级反馈队列 进程间通信方式创建线程因为Thread类实现了Runnable接口 继承Thread类，重写run方法 实现Runnable接口，重写run方法 针对程序来说：main线程作为主线程和子线程Thread-0、Thread-1…交替进行 因此不一定是主方法main线程结束整个程序就会结束 利用JConsole（Terminal终端界面输入命令）监控线程的执行 因为Java是单继承的，当该类已经继承了父类，这时只能通过实现接口来完成线程创建 1234567891011121314151617181920Dog dog &#x3D; new Dog();&#x2F;&#x2F;创建的对象可以当作线程使用 &#x2F;&#x2F;dog.start(); Thread thread&#x3D;new Thread(dog);&#x2F;&#x2F; 表示线程启动 thread.start(); class Dog implements Runnable&#123; @Override public void run() &#123; for(int i&#x3D;0;i&lt;5;i++)&#123; System.out.println(&quot;汪汪&quot;); try &#123;&#x2F;&#x2F;alt+ctrl+t获取快捷创建try&#x2F;catch块 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 继承Runnable接口的线程，要通过创建Thread类将该线程对象放入Thread中 1234Dog dog &#x3D; new Dog();&#x2F;&#x2F;创建的对象可以当作线程使用 &#x2F;&#x2F;dog.start(); Thread thread&#x3D;new Thread(dog);&#x2F;&#x2F; 表示线程启动 thread.start(); 这里用到了代理模式 线程执行1234567891011121314151617Dog dog &#x3D; new Dog();&#x2F;&#x2F;创建的对象可以当作线程使用dog.start();&#x2F;&#x2F;表示线程启动 class Dog extends Thread&#123; @Override public void run() &#123; for(int i&#x3D;0;i&lt;1000;i++)&#123; System.out.println(&quot;汪汪&quot;); try &#123;&#x2F;&#x2F;alt+ctrl+t获取快捷创建try&#x2F;catch块 Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 为什么要通过start()方法来调用线程中的run()方法呢？ 因为run()就是普通的方法，如果直接调用run()那么子线程中未结束的话，作为主线程中的调用一部分，主线程绝对不会结束，只能是串行化执行 start()方法源码解读12public synchronized void start() &#123;&#125; start0()方法是native方法，也就是start0()是真正实现多线程的方法，所以启动多线程不是run() 1private native void start0();&#x2F;&#x2F;通过JVM调用C C++ start()调用start0()方法后，该线程不会立刻执行而是变成了可与行状态，具体什么时候执行，由CPU调度 start0()的具体执行和os有关 Synchronized关键字","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"SpringMVC探究-01","slug":"SpringMVC探究-01","date":"2021-04-22T14:13:10.000Z","updated":"2021-04-22T14:16:33.767Z","comments":true,"path":"2021/04/22/SpringMVC探究-01/","link":"","permalink":"http://example.com/2021/04/22/SpringMVC%E6%8E%A2%E7%A9%B6-01/","excerpt":"","text":"理解SpringMVCSpringMVC就是基于Java实现的MVC模式的轻量级Web框架，这里将Module模型、View视图、Controller控制器分离，解耦合并且通过统一的DispatcherSerblet来管理，并且保留了Spring中面向切面编程和控制反转的优点 SpringMVC的工作原理 SpringMVC的工作核心都是由DispatcherServlet完成的，客户端的所有请求都会交给DispatcherServlet来处理，并且由DispatcherServlet来调用其他模块 DispatcherServlet接收到了用户的请求后，根据发送过来的URL地址，交给HandlerMapping来获取相应的Handler处理器，并返回给DispatcherServlet DispatcherServlet将接收到的Handler交给HandlerAdapter处理器适配器，适配器调用具体的Handler方法返回一个ModelandView对象，ModelandView包含了数据以及对应的视图信息 将ModelandView返回给DispatcherServlet后，还要借助ViewResolver(视图解析器)进行逻辑视图到真实视图的解析工作 返回真正的View对象发送给客户端 web.xml配置1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;&#x2F;servlet-class&gt; &lt;!-- 当applicationContext.xml放在src 下时要特别声明一下，如果不声明，则默认视图配置文件的命名方式为 SpringMVC-servlet.xml--&gt; &lt;init-param&gt;&#x2F;&#x2F;用于DispatcherServlet绑定SpringMVC的配置文件 &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; 标签中由多种写法：&nbsp;&nbsp;&nbsp;/ 只匹配所有的请求，不会匹配jsp界面&nbsp;&nbsp;&nbsp;/* 匹配所有的请求，包括JSP，这样.jsp后缀无限嵌套","categories":[{"name":"Java EE","slug":"Java-EE","permalink":"http://example.com/categories/Java-EE/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"自动化测试简介","slug":"自动化测试简介","date":"2021-04-22T14:12:40.000Z","updated":"2021-04-22T14:12:40.667Z","comments":true,"path":"2021/04/22/自动化测试简介/","link":"","permalink":"http://example.com/2021/04/22/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2021-04-22T14:12:21.000Z","updated":"2021-07-04T14:13:43.037Z","comments":true,"path":"2021/04/22/Linux常用命令/","link":"","permalink":"http://example.com/2021/04/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux命令ls 查看目录下所有文件mkdir 创建目录ll 查看文件属性（可显示文件权限，大小，最近被访问时间等）sudo su普通用户切换到rootsu - lingqixinroot切换到lingqixin用户 查看日志命令 tail -n 显示后多少行的日志 123tail -100f test.log &#x2F;&#x2F;实时监控100行日志tail -n 10 test.log &#x2F;&#x2F;查询日志尾部的最后10行tail -n +10 test.log &#x2F;&#x2F;查询10行之后的所有日志 head -n 显示前多少行日志 123head -n 10 test.log&#x2F;&#x2F;查询日志文件前10行head -n -10 test.log &#x2F;&#x2F;查询日志文件除了最后10行的所有日志 cat -n test.log | grep &quot;debug&quot; 查询关键字的日志 cat -n test.log | grep &quot;debug&quot; | more 日志文件太多使用more分页显示 Linux关于CPU命令 在Linux的系统维护中，可能需要经常查看CPU使用率，分析系统整体的运行情况；而监控CPU性能包括：运行队列、CPU使用率和上下文切换 cat /etc/issue | grep Linux 查看当前系统发行版信息 cat /proc/cpuinfo | grep &quot;cores&quot;| uniq 查看cpu几核 top 总体的系统运行状态和cpu的使用率 %us：表示用户空间程序的cpu使用率 %sy：表示系统空间的cpu使用率，主要是内核程序 %ni：表示用户空间且通过nice调度过的程序的cpu使用率。 %id：空闲cpu %wa：cpu运行时在等待io的时间 %hi：cpu处理硬中断的数量 %si：cpu处理软中断的数量 %st：被虚拟机偷走的cpu dstat 每秒cpu使用率情况获取 dstat --top-cpu最占cpu进程获取 Linux关于进程命令 ps Process Status查看Linux中当前运行的进程的命令，列出系统中运行进程，包括进程号、命令、CPU使用量、内存使用量等 pstree Linux中每一个进程都是由其父进程创建的；pstree以可视化方式显示进程，通过显示进程的树状图来展示进程间关系。如果指定了pid了，那么树的根是该pid，不然将会是init（pid:1） top 实时的监控系统状态信息和进程所使用的资源。显示进程的数据包括 PID、进程属主、优先级(NI)、%CPU、%memory等。可以使用这些显示指示出资源使用量，进程优先级从-20~19，值越低，优先级越高 nice 用户可以设置和改变进程的优先级； nice &lt;优先值&gt; &lt;进程名&gt; - 通过给定的优先值启动一个程序 kill &lt;pid&gt; 用来发送信号给进程，结束进程；可以先使用ps获得进程id号 Linux关于内存命令 free 查看内存的使用情况 total:总计物理内存的大小 used:已使用多大 free:可用有多少 Shared:多个进程共享的内存总额 Buffers/cached:磁盘缓存的大小 第三行(-/+ buffers/cached): used:已使用多大 free:可用有多少 Shell指令echo -n &quot;***&quot;在终端显示***并且不换行echo -e &quot;****&quot;也是显示文字，但是对转义字符按照对应方式处理echo $AA为变量，要输出变量的值一定加上$符号:nuvim格式下，esc后输入显示当前光标所在行号# 单行注释:&gt;&gt;!一行 ！多行注释/root/shcode/myshell.sh &amp;想要一个进程在后台执行要加&amp;","categories":[],"tags":[]},{"title":"Java关键字","slug":"Java关键字","date":"2021-04-22T14:10:17.000Z","updated":"2021-04-22T14:11:39.608Z","comments":true,"path":"2021/04/22/Java关键字/","link":"","permalink":"http://example.com/2021/04/22/Java%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"final关键字final关键字可以修饰类、修饰成员方法、修饰成员变量 修饰类表示该类不能被继承，可以防止滥用继承带来的危害，例如String类 String类同时也是static的，这也就解释了为什么main函数下使用String，却不需要实例化String源码中表示实际上String类是被final修饰的一个char数组，String设定为final类型主要就是为了安全 Java并不是操作系统的本地语言，也就是Java的内部类都是用别的语言来写的，这种调用本地类的方法频繁的和os打交道，如果这种类可以随便被继承，那么有可能将被人恶意写入攻击代码字符串不可变，也就导致了在创建的时候hashcode值就确定了，不需要重新计算，这样的字符串很适合作为Map键 修饰成员方法表示该方法不能被重写，但是可以被继承 修饰成员变量如果是基本数据类型变量，表示该成员变量必须赋值并且不可以更改，例如圆周率，Thread类中MAX_PRIORITY值如果是引用类型变量，对其初始化后，就不能让其指向另一个对象 final不能用于修饰构造方法，因为子类一定要重写父类的构造方法！！！","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"随记二","slug":"随记二","date":"2021-04-22T13:27:57.000Z","updated":"2021-04-22T13:27:57.761Z","comments":true,"path":"2021/04/22/随记二/","link":"","permalink":"http://example.com/2021/04/22/%E9%9A%8F%E8%AE%B0%E4%BA%8C/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"随记一","slug":"随记一","date":"2021-04-18T13:23:51.000Z","updated":"2021-04-18T13:28:54.500Z","comments":true,"path":"2021/04/18/随记一/","link":"","permalink":"http://example.com/2021/04/18/%E9%9A%8F%E8%AE%B0%E4%B8%80/","excerpt":"","text":"今天在刷知乎的过程中想到了一个问题“为什么你喜欢刷知乎？” 看到一篇很有诗意的回答，记录下来： 当你窝在宿舍那小小的几平方米，电脑桌面满是下好的论文。身边的人各自做着各自的事，白色灯管里发出的光总是带了那么点疏离的意味。饭早就匆匆在食堂解决过了，炊烟中的烟火气成了宿舍楼群望而不得的人间。楼下偶尔能传上来附近居民锻炼时候发出的声响，老的少的，有点肆无忌惮的热闹。你越发觉得自己身处一座孤岛，不算与世隔绝，但对这座城市总有着那么点说不清，道不明的感觉，就像白色灯管发出的灯光，很亮，也很疏离。这时候你很想去看看别人的故事，就好像能够顺带路过别人的人生。 你关注了知乎中很多话题，就比如：你最怦然心动的一个瞬间是什么？你最感动的体验是怎样的？……诸如此类。 你跟着答案一起穿过窄巷子，和一个老爷爷一起听昆曲咿咿呀呀；一起走进一家老旧的咖啡馆，听老板给讲两个时光中的故事；又或者一起在一个下了雪的下午，围坐在暖炉旁边感受阳光的气息…… 你突然觉得你的孤岛中，有了那么点摇摇曳曳的闪光。 ——来自知乎 看完很有感悟，其实知乎上的各种成功人士的答案并没有让我变成所谓的“成功人士” 翻了自己的回答，无外乎都是希望找到看法一样的人，一起分享快乐，把不能和周围人说的，或者是找不到倾诉的，分享给知乎上的朋友 这对我而言足够了~","categories":[{"name":"随记","slug":"随记","permalink":"http://example.com/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://example.com/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"数据库知识点","slug":"数据库知识点","date":"2021-04-14T09:50:52.000Z","updated":"2021-04-22T14:09:44.600Z","comments":true,"path":"2021/04/14/数据库知识点/","link":"","permalink":"http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"数据库怎么加快查询速度：尽可能优化查询语句，避免使用order by和group by(会占用大量的临时空间，可创建视图来代替)， 避免使用like等通配符正则表达式，创建索引加快 123SELECT * FROM table1 WHERE field1&lt;&#x3D;10000 AND field1&gt;&#x3D;0;SELECT * FROM table1 WHERE field1&gt;&#x3D;0 AND field1&lt;&#x3D;10000;&#x2F;&#x2F;更好，where语句中把最具限制性的条件放在最前面 创建索引： 1create index index_name on table_name(column_list) [tablespace tablespace_name] 举个栗子： 1234567891011如果我们经常对emp表进行按照empno来查询某个员工的信息，SQL&gt; select * from emp where empno&#x3D;7788; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7788 SCOTT ANALYST 7566 1987-4-19 3000.00 20我们就应该对empno这一列建一个索引。create index indx_on_empno on emp(empno) tablespace users; 1234567891011121314151617如果我们经常查询某个部门工资大于1000的员工信息，那么我们就可以在job和sal列上建立所以，这叫组合索引：SQL&gt; select * from emp 2 where job&#x3D;&#39;SALESMAN&#39; and sal&gt;1000; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO----- ---------- --------- ----- ----------- --------- --------- ------ 7499 ALLEN SALESMAN 7698 1981-2-20 1600.00 300.00 30 7521 WARD SALESMAN 7698 1981-2-22 1250.00 500.00 30 7654 MARTIN SALESMAN 7698 1981-9-28 1250.00 1400.00 30 7844 TURNER SALESMAN 7698 1981-9-8 1500.00 0.00 30 create index indx_on_job_sal on emp(job,sal)tablespace users; 数据库索引的底层原理——B树索引 数据库也好，磁盘查找也好，都是将部分数据调入内存后，进行查找比对，这样就会涉及到一个调入数据进入内存的问题，要调入多少数据进入内存，就是设计数据在外存中的存储的重点了！！！ B树的结构：图片/5.png B树的阶数不像二叉树一样必须是2，而是不限制阶数，因此就可以变得“矮胖的” 数据库索引的分类： 唯一索引： 不允许其中的任何两行具有相同的索引值 例如在employee表中name上创建索引，就表示任何两个员工都不能具有相同的姓名 主键索引: 在数据库创建主键后自动创建主键索引，主键索引也是唯一索引的特殊情况 聚集索引 数据库中的锁锁的分类：数据库系统角度：排他锁、共享锁、更新锁 程序员角度：悲观锁、乐观锁 悲观锁悲观锁，像名字一样，每次用到数据的时候都会认为别人会对数据进行修改，所以每次使用数据都会上锁，并且悲观锁增加了死锁的机会 这种锁都是在操作之前先上锁 悲观锁按照使用性质划分： 共享锁（S锁、读锁）——用于所有的只读操作，并非是独占的，允许多个并发的事务来读取数据，但是任何的事务都不能对其进行修改，读取完毕后，立即释放锁 123456SELECT * FROM my_table&#x2F;&#x2F;先锁定第一页，读取后释放，再锁第二页SELECT * FROM my_table HOLDLOCK&#x2F;&#x2F;要求整个查询的过程中，保持对表的锁定 排他锁（X锁、写锁）——事务为对象设置排他锁后，其他事务不允许读或写，X锁不同于S锁，直到事务结束后才能被释放 更新锁（U锁）——在修改操作之前就锁定可能要修改的资源，避免产生死锁 1234可能产生死锁的原因：当A事务申请对U资源的共享锁时，B事务也在使用共享锁读P资源数据；然后A事务设置排他锁来对P写数据，但是B事务也要申请排他锁来对U写数据，对方都想等待记录，但是对方都不放资源，造成死锁当A事务在写P资源之前，首先对P设置更新锁，这样B事务就不会再对P上锁，不会发生死锁 悲观锁按照所用范围划分： 行锁、表锁 乐观锁乐观锁，就是每次使用数据的时候，都认为别人不会进行修改，所以就不会上锁，但是再更新的时候会判断一下在操作期间别人有没有更新这个数据，可以使用版本号机制 版本号： 给数据表增加version字段，每次更新将字段+1，读数据的时候将version读入，要更新数据后比较version是否发生了变化： 发生了变化就反馈给用户，让用户自己判断，可以重新开始，并且这里面判断version和用户更新为一个原子单元执行，否则会出现，判断后没有更新，但是在判断过程中发生了更新，没有反馈给用户的情况 时间戳——同版本号 这里的时间戳不是系统时间而是数据库服务器时间 待更新字段 不另外设置时间戳或者版本号等标识，而是直接比较数据库中的某个字段的数据是否发生了改变 两者不同点悲观锁虽然安全，但是也使得数据库效率下降，性能开销变大，对于长事务来说更为明显 并发控制可能产生的两种不良情况死锁 预防方法： 一次封锁法、顺序封锁法（更新锁） 活锁 按照事务的优先级不同，比如T1事务封锁数据R，之后T2请求封锁R，T3也请求封锁R，T4也请求封锁R，但是这里T2的优先级最低就导致了T2永远也等不到数据，这里可以使用先来先服务策略避免 对于高并发的情况下建议尽量使用乐观锁 首先是悲观锁增加了产生死锁的概率，一旦产生死锁，对系统的消耗巨大，长时间限制其他用户的访问，并发性并不好； 而乐观锁减少了过多的加锁的步骤，提高性能，并且乐观锁出现差错的情况纪律比较小 乐观锁可能失效的情况： 123456常见的取当前ID字段的最大值＋1作为新ID版本号字段 version 默认值为 0用户A读取了某个记录准备修改它该记录正好是ID最大的记录，且之前没被修改过，version 为默认值 0在用户A读取完成后，用户B恰好删除了该记录。之后，用户C又插入了一个新记录此时，阴差阳错的，新插入的记录的ID与用户A读取的记录的ID是一致的， 而版本号两者又都是默认值0 数据库事务","categories":[{"name":"计算机知识点","slug":"计算机知识点","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E7%82%B9/"}],"tags":[{"name":"数据库知识点","slug":"数据库知识点","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"计算机网络知识点","slug":"计算机网络知识点","date":"2021-04-14T09:49:07.000Z","updated":"2021-04-22T14:44:49.239Z","comments":true,"path":"2021/04/14/计算机网络知识点/","link":"","permalink":"http://example.com/2021/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"Http常见状态码：http状态码表示客户端http请求的返回结果，标记服务器端的处理是否正常或者是出现的错误 其中第一位指定了相应类别 1xx 接受的请求正在处理2xx 请求正常处理完毕3xx 需要进行附加操作来完成请求（比如重定向）4xx 客户端请求错误，服务器无法处理5xx 服务器处理请求错误 2xx200 OK 请求正常处理并返回204 No Content 返回的报文中没有资源返回206 Patial Content 3xx301 Moved Permanently 永久性重定向 请求的资源被分配了新的URL302 Found 临时重定向，后续可能还会更改URL303 See Other 类似302，但是表明客户端应采取get方式获取资源304 Not Modified307 Temporary Redirect 临时重定向和303相同 4xx400 Bad Request 报文中存在语法错误401 Unauthorized 未经许可，要通过http认证403 Forbidden 服务器拒绝本次访问404 Not Found 服务器上无法找到请求的资源 5xx500 Inter Server Error 服务器执行请求时发生错误503 Server Unavailable 服务器暂时处于超负载运行中，无法处理请求 tcp为什么比udp可靠：tcp是面向连接的而udp无连接直接发送数据 tcp提供可靠地服务，通过tcp传送的数据，无差错，不丢失，不重复，顺序不变；而udp只是尽可能的交付数据 tcp在确认客户端接收到完整信息后，才会删除服务端系统中数据缓存 tcp的可靠服务基于：校验和，重传机制，序号标识，滑动窗口，确认应答 但是tcp只是点到点的，udp支持多对多传输通信 tcp滑动窗口机制tcp之前使用的停等协议，完全依靠RTT超时重传机制，但是这样的话浪费资源，发送数据包的效率底下，出现的滑动窗口可以很大程度的改善并且扔保证tcp可靠传输，接收数据包顺序不改变的特点 tcp的滑动窗口以字节为单位，并且将数据报文段分成四个部分——发送并且已确认、已发送但是未确认、未发送但是等待发送、未发送并且不可以发送接受方首先发送了报文中确定了接收方的窗口大小-20，ack值-31表明接收方期望收到来自发送方的31号序列号开始的报文 发送方收到这两个字段后，就可创建自己的发送窗口-20，这个窗口内发送的数据包在未收到ACK确认时都要进行保留，方便在因为网络原因超时重传的时候来重发 接收方接收到位于接收窗口内的数据，就可以暂时缓存，一边后续提交给上层；但是当接受的包中出现丢包的情况，可能就会再次发送累计ACK要求发送方重传； 报文按序到达后，发送最大的ACK表示期望收到的下一个报文序号，这时候接收方的滑动窗口向后移动，发送方收到ACK后也向后移动 tcp拥塞控制拥塞控制算法的假定条件：数据单方向传送，接收方只发送确认报文接收方总是有足够大的缓存空间，所以发送方的窗口大小由网络的拥塞程度决定以最大报文段MSS的个数作为讨论单位，而不是字节 发送方维护一个叫做cwnd的拥塞窗口变量，取决于网络的拥塞程度，并且动态变化只要网络中没有出现拥塞，那么拥塞窗口就会增大一点，但是只要出现了拥塞，窗口就会减小 判断网络出现拥塞的依据：没有按时收到应当到达的确认报文就是出现了超时重传现象 发送方将拥塞窗口作为发送窗口swnd 发送方维护了一个叫做慢开始门限ssthresh的变量 当cwnd &lt; ssthresh时，使用慢开始算法当cwnd &gt; ssthresh时，停止使用慢开始而改用拥塞避免算法当cwnd = ssthresh时，两者都可 慢开始 为啥指数增长还叫慢开始？慢开始是刚开始注入网络的报文段少，因为虽然窗口增长很快，但这里的慢描述的是慢慢增长的过程，是为了试探拥塞的限度 拥塞避免 快重传使发送方尽快重传，而不是等超时后在重传/12.jpg接受放一直给发送方发送累计ACK（ACK3表明我接受方期望收到的是3号报文），比如收到了1、2号报文，3丢失，4，5，6收到，但是接收方一直发送ACK3表示我要的是3号，当累计收到连续的3个重复ACK时，就将该号报文立刻重传，而不是等到超时 块恢复 慢开始+拥塞控制（Tahoe） 一开始从初始设定的cwnd的拥塞窗口初始值开始发送，并且每个传输轮次发送窗口swnd指数增长，当达到慢开始门限值时，开始使用拥塞避免算法，拥塞窗口值每次+1直到发送方检测到出现了丢包进行超时重传的现象，这时候设定新的ssthresh(慢开始门限)为当前发生网络拥塞时的拥塞窗口的一半（1/2cwnd），并从cwnd=1重新开始指数增长，直到达到新的ssthresh时再次启用拥塞避免算法窗口+1 快重传+快恢复（Reno） 有时，个别的报文段丢失并不是网络拥塞造成的，这导致发送方重传误以为拥塞/13.jpg 当发送方收到了三个重复确认的报文段时，启动快重传，但是此时不在进行慢开始算法，而是使用快恢复算法，更新慢开始门限值ssthresh为当前拥塞窗口的一半（1/2cwnd），并且此时的cwnd值不是1，而是等于新的ssthresh值（cwnd=ssthresh）此后在每次cwnd+1增长 http8种请求方式 方法 描述 Get 请求指定的页面内容，并返回实体主体 Head 类似于get，但是返回的响应种没有具体内容，用于获取报头 Post 向指定资源提交数据处理请求（表单或文件），数据包含在请求体中 Put 从客户端向服务器传送的数据取代指定的文档内容 Delete 请求服务器删除指定界面 Connect http1.1中预留给能够将链接方式改为管道方式的代理服务器 Options 允许客户端查看服务器性能 Trace 回显服务器收到的请求，用于测试和诊断 其中Post支持的数据格式：","categories":[{"name":"计算机知识","slug":"计算机知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"JVM探究","slug":"JVM探究","date":"2021-04-14T09:47:46.000Z","updated":"2021-07-04T14:12:23.622Z","comments":true,"path":"2021/04/14/JVM探究/","link":"","permalink":"http://example.com/2021/04/14/JVM%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"概述本机虚拟机类型——JavaHotSpot 1cmd→ java -version JVM位置JVM运行在os之上，JVM是使用C写的程序；JRE包含了JVM； JDK包含JRE，JRE包含JVMJDK：Java development kit——Java开发工具包JRE：Java runtime environment——Java的运行环境（lib+bin）JVM：Java Virtual machine——Java虚拟机 Java平台下，所有的Java程序都要在JRE环境下运行，JVM解释class文件的时候，需要调用解释用到的类库lib;但是JRE不包含Java的运行工具（编译器，调试器等） JDK就包括了Java的运行环境、工具（javac）、Java基础类库（Java API：Java的应用程序接口，包括已经写好的Java class文件等，可以直接调用） 但是我的电脑中有两个相同版本的JRE和JDK: JDK内外的JRE都可以为Java提供开发的运行环境，但是JDK自带的开发工具只能使用自己的JRE 实际开发：JDK调用本地API开发Java程序，通过JDK中javac工具编译成Java.class后，在外部JRE上运行字节码文件，JVM来解释.class文件变成机器语言后再不同的os上使用 在JVM中垃圾只能存在于堆和方法区中，栈、本地方法栈、程序计数器内不可能有垃圾，也不会有垃圾回收，否则无法弹出的话，最下面的main方法无法弹出，程序没有出口 因此JVM的调优就是在堆内调优 类加载器 —— 加载.class文件类加载器主要负责三项任务：载入、链接、初始化 当new Student()时，该Student类的具体实例引用在栈中，而实例对象放在堆中 类加载器包含：虚拟机自带加载器，启动类（根）加载器(EXCClassLoader)（在rt.jar中），扩展类加载器，应用程序加载器（AppClassLoader） 1234567class AA.getClass();&#x2F;&#x2F;获取类名A.getClassLoader();&#x2F;&#x2F;获取类加载器A.getClassLoader().getParent();&#x2F;&#x2F;获取上层父类加载器 双亲（上层）委派机制：——向上委托，向下加载 在类加载器为了生成.class文件时，首先按照如下顺序找到类加载器： APP–&gt;EXC–&gt;ROOT–&gt;null(因为Java的底层是用C、C++来写的，丢掉了指针，将内存管理交给JVM来做) 最后找到根加载器进行加载，没有的话在回退找到加载器，都找不到的话就会报错:Class Not Found 这样安全性高的机制也必然导致了性能下降 沙箱安全机制 对于非本地的代码，在沙箱中运行~没写完(～￣▽￣)～ Java实例化和初始化的区别123public class A&#123; A() &#123;&#125;&#125; 类的初始化是构造函数完成的，在程序开始run的一瞬间，类以及静态的东西都在内存中开始初始化 1A a&#x3D;new A();&#x2F;&#x2F;实例化 类的加载只执行一次，也就是初始化一次，只有一个类的对象，而实例化是有一个new就会有一个实例化对象 1A a&#x3D;null;&#x2F;&#x2F;这只是声明 这也就解释了为什么main是static的情况： 在Java中所有的程序都是在类的基础上运行的，但是刚刚运行的程序没有任何类，没有类怎么加载类，没有加载类怎么出现类，这样的话就陷入了死循环； 利用static关键字，因为static不需要依赖实例对象而存在，所以通过static main()来创建一系列的对象，这样就可以继续加载其他的类了 native关键字12345public class Demo&#123; public void hello();&#x2F;&#x2F;接口报错，只能在抽象类中 public native void hello();&#x2F;&#x2F;成功&#125; 包含native关键字的方法，不在受到java管辖，而是调用底层C语言的库！ 会进入本地方法栈 Native Method Statck，在调用JNI（Java Native interface）接口找到本地方法接口，在调用本地方法库就可以扩展Java的方法 在JVM中的本地方法栈中登记了native方法，在最终执行的时候找到本地方法库的方法 例如Java程序驱动打印机，就可以使用native关键字 PC程序计数器每个线程都有一个程序计数器，是线程私有的，就相当于一个指针，指向下一条要执行的语句 方法区Java虚拟机中明确说明：方法区 作为堆的一部分，但是是独立于堆的内存空间 方法区和堆一样，是线程共享的内存区域 方法区在JVM启动时被创建，和堆一样都是不连续的物理空间，空间大小可以扩展 方法区的大小决定了可以保存多少类，定义了太多类或者过多的引用第三方的jar包，也会导致方法区溢出 关闭JVM就会释放这个方法区的内存 1234567891011public class Test&#123; private int a; private String name&#x3D;&quot;lingqixin&quot;; &#x2F;&#x2F;当name赋初值后这个初值就会放在常量池中 public static void main(String[] args) &#123; Test test1&#x3D;new Test(); test1.name&#x3D;&quot;new lingqixin&quot;; &#x2F;&#x2F;要是没有被赋新的值，就要从常量池中获得 &#125;&#125; JVM中的堆和栈1.栈： 线程结束，栈就会Over 栈中存放的内容： 函数中定义的八大基本类型（char,short,int,float,double,long,boolean,byte)以及引用变量都在栈中分配（就相当于数组的名称） 123int a&#x3D;3;int b&#x3D;3; 2.堆： 栈是线程级别的，但是一个JVM只有一个堆 当类加载器加载了类后，会将该类的方法，常量值，变量值，保存引用值的对象 堆内存分成三个区域： 新生代：伊甸园（new产生）、幸存区0、幸存区1老年代：永久代（jdk1.8后被元空间取代）！！ GC垃圾回收主要在伊甸园和老年代 当出现OOM的堆内存满了的错误时","categories":[{"name":"Java原理","slug":"Java原理","permalink":"http://example.com/categories/Java%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"Java知识点","slug":"Java知识点","date":"2021-04-14T09:46:10.000Z","updated":"2021-04-22T15:06:01.623Z","comments":true,"path":"2021/04/14/Java知识点/","link":"","permalink":"http://example.com/2021/04/14/Java%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"区别equals、hashCode()和====说明： 对于8个基本数据类型，判断的是操作数的值是否相等 两个类对象==判断，是判断其在栈中所指向的堆中的地址值 1234String s1&#x3D;&quot;tom&quot;;String s2&#x3D;&quot;tom&quot;;System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;返回结果为true 这里第一个s1在JVM的堆的常量池中已经创建了一个叫做”tom”的常量，s1存放的是堆中的地址 在s2时，因为常量池中已经有了一个”tom”，所以s2也指向该”tom”，s1与s2的指向地址相同 1234String s1&#x3D;&quot;tom&quot;;String s2&#x3D;new String(&quot;tom&quot;);System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;返回结果为false 这里new之后相当于在堆内存中重新开辟一段新的空间去存储”tom”，因此s1,s2指向的地址不相同 equals()说明 Object类中的equals源码： 1234public boolean equals(Object obj) &#123; return (this &#x3D;&#x3D; obj); &#125; 所以Objct中的equals方法和”==”并没有不同，都是比较的地址是否相等 这也是为什么euqals()要重写的原因 反过来看equals源码: 12345678910111213141516171819202122232425public boolean equals(Object anObject)&#123; if(this&#x3D;&#x3D;anObject)&#123; return true; &#125;&#x2F;&#x2F;首先判断s1和s2 &#x3D;&#x3D;来比较地址值是否相同，不相同的话，往下进行 if(anObject instanceof String)&#123;&#x2F;&#x2F;instanceof用来判断传入的值是否为String类型的实例，如果不是直接false String anotherString &#x3D; (String) anObject;&#x2F;&#x2F;将s2转换为String int n&#x3D;this.value.length;&#x2F;&#x2F;获取s1的长度 if(n &#x3D;&#x3D; anotherString.value.length)&#123;&#x2F;&#x2F;首先判断两者长度是否相同，不同就直接false char v1[] &#x3D; value; char v2[] &#x3D; anotherString.value; &#x2F;&#x2F;拆分字符串为数组[&#39;t&#39;,&#39;o&#39;,&#39;m&#39;] int i&#x3D;0; while(n-- !&#x3D;0)&#123; if(v1[i]!&#x3D;v2[i]) return false; i++; &#125; return true;&#x2F;&#x2F;字符串完全相同，返回true &#125; &#125; return false;&#125; equals说明： 1.equals在Object中比较的还是对象的内存地址，而String方法对equals进行了重写，因此String中比较的就是对象的值； 2.String类型创建对象首先要看在JVM的堆常量池中是否有相同的要创建的值，如果有就赋给当前的引用 hashCode()说明： hashCode()是Object中的native方法，用于获取对象的哈希值，用于确定该对象在哈希表中的索引位置 也就是将数据的内部存储地址转换成一个整数然后返回 Object中hashCode()源码： 1public native int hashCode(); hashCode()的存在也决定了数据在哈希表中的存储方式： 要放入到哈希表中的元素首先要经历一些判断： （1）通过hashCode()来获取hash值，这个值也就是通过哈希函数获取的在数组中的位置值，根据哈希函数的运算规则，这个值有可能相同，不同的话，那就绝对不存在这个对象，可以创建新的空间放入到集合中 （2）如果hash的值相同，但是也不等说明两个完全一样，要进行equals判断，发现与已经存在的对象equals值也相同的话，就可以舍弃；否则创建该对象 这就得到了hashCode()和equals的关系： 如果重写了equals方法，有必要重写hashCode()方法的： 两个对象equals()返回为true，则hashCode()必为true 两个对象equals()返回false，则hashCode()不一定就不同 两个对象hashCode()返回相同int，则equals()返回不一定为true 两个对象hashCode()返回不同int，则equals()返回必定为false 基本数据类型所占字节大小 基本数据类型和对应的包装类的区分 Integer和int区别: Integer是int的包装类，int是Java的基本数据类型 Integer要实例化才使用，int不用 Integer默认为null,int为0 1234Integer i &#x3D; new Integer(100);int j &#x3D; 100；System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true Integer和int相比较的时候，只要值相同结果相等，比较时Java将Integer自动拆包装为int 1234Integer i &#x3D; new Integer(100);Integer j &#x3D; 100;System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false 当变量值在-128~127，非new生成的Integer对象是常量池的中的，而new生成的是堆中新建的，内存地址不同； 当不在区间时，非new生成的最终按照new处理，两个地址同样不同 也解释了下面： 12345678Integer i &#x3D; 100;Integer j &#x3D; 100;System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;trueInteger i &#x3D; 128;Integer j &#x3D; 128;System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false Java中this详解this指向的是当前对象的引用this.方法名称——用来访问本类的成员方法 Java中的块{}以及实例化和初始化顺序1.{}定义在方法中，就是调用方法的时候执行 2.{}定义在类中，方法外，表示一个构造块；在创建对象的时候，首先找构造器，有构造块，先执行块中内容，再执行构造器中内容 3.static{}定义在类中，方法外，表示一个静态块；在第一次类加载完毕后执行，并且只执行一次，静态块优先于方法执行 4.synchronized(){}同步代码块，写在方法中 执行顺序：静态块(静态变量：按照编写顺序来，并且都只加载一次)→主方法（main）→成员变量、构造块（按照编写顺序来）→构造器代码→静态方法（调用了才加载） 1234567891011121314151617181920212223242526272829public class Demo &#123; int a &#x3D; print(3);&#x2F;&#x2F;5.加载成员变量，调用print(3)，输出&quot;实例3&quot; public Demo() &#123; System.out.println(&quot;构造方法&quot;);&#x2F;&#x2F;8.最后执行构造方法 &#125; &#123; System.out.println(&quot;非静态块&quot;);&#x2F;&#x2F;6.顺序执行到非静态块，输出&quot;非静态块&quot; &#125; int b &#x3D; print(4);&#x2F;&#x2F;7.加载成员变量，调用print(4)，输出&quot;实例4&quot; public int print(int value) &#123; System.out.println(&quot;实例&quot; + value); return value; &#125; static int i &#x3D; printStatic(1);&#x2F;&#x2F;1.加载静态变量，调用方法printStatic()，输出&quot;静态1&quot; static &#123; System.out.println(&quot;静态块&quot;); &#125;&#x2F;&#x2F;2.按照顺序加载静态块，输出&quot;静态块&quot; static int j &#x3D; printStatic(2);&#x2F;&#x2F;3.调用printStatic()，输出&quot;静态块2&quot; public static int printStatic(int value) &#123; System.out.println(&quot;静态&quot; + value); return value; &#125; public static void main(String[] args) &#123; new Demo();&#x2F;&#x2F;4.开始执行主方法，到了类实例化过程 &#125;&#125; Java的反射机制反射机制：将类的各个组成部分封装成对象 为什么Java中总是经常重写toString()方法？123public String toString();&#x2F;&#x2F;返回该对象的字符串表示 如果不重写该方法，返回的打印输出的值就是——对象类型+@+内存地址值 12Person@1b6d3456&#x2F;&#x2F;getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode()); 当重写toString()方法后，打印的就是该对象中属性的值了 1234567891011 &#x2F;&#x2F; 重写toString方法 @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age&#x3D;&quot; + age + &quot;, name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, height&#x3D;&quot; + height + &#39;&#125;&#39;; &#125;&#x2F;&#x2F;打印：Person&#123;age&#x3D;0,name&#x3D;&#39;null&#39;,height&#x3D;null&#125; Java中重载和重写的区别 比较点 重写（Overriding） 重载(Overloading) 类数量 父子类、接口、实现类 本类 方法名称 相同 相同 参数列表 一定不能修改 必须修改 返回类型 一定不能修改 可以修改 异常 可以减少或删除，但不能修改 可以修改 重载 重载发生在本类中，方法名必须相同，参数列表必须不同，但是和返回值、访问修饰符无关，值和方法名、参数列表、参数类型有关 重载其实就是不同种情况的写法，就相当于都是跑步，唯一不同的就是用的工具不同，但是返回值（也就是结果不会影响） 123456789101112class Test&#123; public void run(int foot)&#123; System.out.println(&quot;步行&quot;); &#125; public int run(String bike)&#123; System.out.println(&quot;自行车&quot;); return 1; &#125; protected void run(char train)&#123; System.out.println(&quot;坐火车&quot;); &#125;&#125; 重写 重写发生在父类子类之间，比如所有类都是继承Object类的，Object类中本身的equals、hashcode、toString方法，在任意子类中第一了重名和同样参数列表的话就是重写 这样的话方法名、参数类型、参数列表、返回值都必须要相同 访问权限不能比父类中被重写的方法更低，也就是只有长辈很难访问，后辈更容易被访问，不能反了；父类为public，子类不能是private或protected 父类和子类在同一个包中，子类除声明为private和final的方法外都可以重写父类方法 接口和抽象类区别 比较点 接口 抽象类 方法 所有方法都是抽象的 同时包含抽象和非抽象方法 与其他类 类可以实现多个接口 类只能单继承一个抽象类 实现 可以不实现其中所有的方法 可以不实现其中的所有方法 成员变量 只能有static final成员变量 随意 实例化 不可以实例化，可以创建指向子类的对象 实现该接口的类必须实现接口中所有方法 深拷贝和浅拷贝浅拷贝 浅拷贝只拷贝了源对象的地址，源对象的值发生改变时，拷贝对象的值也会发生改变 这种=浅拷贝就是因为Java约定处理基本类型的时候使用的是值传递，而引用类型时采用的是引用传递，也就是地址给新的对象，但是指向堆内同一个位置!!!不准确，Java都是值传递？？？！！！ 为什么大家都说Java只有值传递？ 123456User user1 &#x3D; new User();user1.setUsername(&quot;林启昕&quot;);user1.setPassword(&quot;123&quot;);&#x2F;&#x2F;浅拷贝User user2 &#x3D; user1; System.out.println(user1);System.out.println(user2);&#x2F;&#x2F;输出的地址值相同 深拷贝 拷贝了一份值相同的新的对象，两者不再关联，地址不同 深拷贝的方式： 构造函数(new)？？？这个不是创建对象吗但是创建对象过多时，new开销过大，不建议使用构造函数来拷贝 重写clone方法类实现Cloneable接口，并且重写Object中的clone()方法 12345&#x2F;&#x2F;Object中的clone()方法@Overrideprotected Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 12345&#x2F;&#x2F;重写clone()方法@Overridepublic User clone() throws CloneNotSupportedException &#123; return (User)super.clone();&#125; User深拷贝，这里调用的clone()方法时要用try/catch块接收异常 123456789101112User user1 &#x3D; new User();user1.setUsername(&quot;林启昕&quot;);user1.setPassword(&quot;123&quot;);&#x2F;&#x2F;浅拷贝User user2 &#x3D; null;try &#123; user2 &#x3D; user1.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125;System.out.println(user1);System.out.println(user2); 当类中只有一些基本数据类型的对象时，就可以采用上述方法进行深拷贝，但是当包含引用类型的对象时，就不能只是在该类中对类进行clone()，还要对非基本数据类型属性值也进行clone 上述所说的非基本类型中不包含String?? 1234567891011121314151617181920212223242526272829303132333435import java.util.Date;class Obj implements Cloneable &#123; private Date birth &#x3D; new Date(); &#x2F;&#x2F;对象 public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth &#x3D; birth; &#125; public void changeDate() &#123; this.birth.setMonth(4); &#125; public Object clone() &#123; Obj o &#x3D; null; try &#123; o &#x3D; (Obj)super.clone(); &#x2F;&#x2F;先执行浅复制 &#125;catch(CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; o.birth &#x3D; (Date)this.getBirth().clone(); &#x2F;&#x2F;深复制，没有这一步的话，两个对象的运行结果都是4月，原因是后面的深复制和浅复制的区别 return o; &#125;&#125;public class HashMap_ &#123; public static void main(String[] args) &#123; Obj a &#x3D; new Obj(); Obj b &#x3D; (Obj)a.clone(); b.changeDate(); System.out.println(&quot;a:&quot;+a.getBirth()); System.out.println(&quot;b:&quot;+b.getBirth()); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"粤语歌——《完》","slug":"粤语歌——《完》","date":"2021-04-06T08:01:42.000Z","updated":"2021-04-06T08:16:16.550Z","comments":true,"path":"2021/04/06/粤语歌——《完》/","link":"","permalink":"http://example.com/2021/04/06/%E7%B2%A4%E8%AF%AD%E6%AD%8C%E2%80%94%E2%80%94%E3%80%8A%E5%AE%8C%E3%80%8B/","excerpt":"","text":"http://music.163.com/song?id=64048&amp;userid=1659092624 手一僵 眼闭着 未能延着 别求延着","categories":[],"tags":[{"name":"粤语歌","slug":"粤语歌","permalink":"http://example.com/tags/%E7%B2%A4%E8%AF%AD%E6%AD%8C/"},{"name":"陈奕迅","slug":"陈奕迅","permalink":"http://example.com/tags/%E9%99%88%E5%A5%95%E8%BF%85/"}]},{"title":"搭建博客问题汇总","slug":"搭建博客问题汇总","date":"2021-04-03T14:33:05.000Z","updated":"2021-04-04T02:59:04.576Z","comments":true,"path":"2021/04/03/搭建博客问题汇总/","link":"","permalink":"http://example.com/2021/04/03/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"","text":"1.网络问题： 可能因为翻墙吧。。。所有外网访问都是问题（额） 1OpenSSL SSL_read: Connection was reset, errno 10054 大概是网络不稳定，链接超时导致的，还有就是ssl密钥？执行这个命令，解除ssl验证： 1git config --global http.sslVerify &quot;false&quot; 第一次执行这条命令的时候会有git的ssl链接输入密码？？（大概是，具体我查查） 我的天完事开头难，我就插入个上面的截图给我搞得心态爆炸了o(*≧▽≦)ツ┏━┓ 2.还是网络问题： 因为要翻墙，但是挂的梯子还是不稳定总是出现“Failed to connect to github.com port 443: Timed out”的问题，干脆面向百度解决问题，修改了hosts文件，对访问github别在受限了啊啊啊啊啊 在hosts文件里面加上这个： 123#github#192.30.253.112 github.com#151.101.185.194 github.global.ssl.fastly.net 因为hosts为系统文件，在修改之前右键点击属性-安全-找到电脑用户Users-增加一下权限就可以了 绝了绝了！！！！！修改了第二条，第一条的指令不用加上了！！！！！掘了掘了！！！好吧。。并没有，我试了一次，还是要第一条emmmmmm","categories":[],"tags":[]},{"title":"idea快捷键汇总","slug":"idea快捷键汇总","date":"2021-04-03T13:03:07.000Z","updated":"2021-04-03T13:03:07.301Z","comments":true,"path":"2021/04/03/idea快捷键汇总/","link":"","permalink":"http://example.com/2021/04/03/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"手撕算法——查找","slug":"手撕算法——查找","date":"2021-04-02T09:16:13.000Z","updated":"2021-04-03T12:47:19.582Z","comments":true,"path":"2021/04/02/手撕算法——查找/","link":"","permalink":"http://example.com/2021/04/02/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/","excerpt":"","text":"顺序查找适合存储结构为顺序存储或这链接存储的线性表 思路顺序查找从第一个元素开始查找，不论要查找的列表有序无序，将扫描到的值和关键字比较，相等则成功；否则查找失败，则不成功 代码123456789public static int sequenceSearch(int[] array, int k) &#123; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == k) return i; &#125; return -1; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"查找","permalink":"http://example.com/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-04-02T08:17:44.819Z","updated":"2021-04-02T08:17:44.819Z","comments":true,"path":"2021/04/02/hello-world/","link":"","permalink":"http://example.com/2021/04/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"随记","slug":"随记","permalink":"http://example.com/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"编程","slug":"编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Java API","slug":"Java-API","permalink":"http://example.com/categories/Java-API/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Java EE","slug":"Java-EE","permalink":"http://example.com/categories/Java-EE/"},{"name":"计算机知识点","slug":"计算机知识点","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"计算机知识","slug":"计算机知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"},{"name":"Java原理","slug":"Java原理","permalink":"http://example.com/categories/Java%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"随记","slug":"随记","permalink":"http://example.com/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java Collections","slug":"Java-Collections","permalink":"http://example.com/tags/Java-Collections/"},{"name":"笔试习题","slug":"笔试习题","permalink":"http://example.com/tags/%E7%AC%94%E8%AF%95%E4%B9%A0%E9%A2%98/"},{"name":"计算机基本知识","slug":"计算机基本知识","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"},{"name":"Java API","slug":"Java-API","permalink":"http://example.com/tags/Java-API/"},{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据库知识点","slug":"数据库知识点","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"},{"name":"粤语歌","slug":"粤语歌","permalink":"http://example.com/tags/%E7%B2%A4%E8%AF%AD%E6%AD%8C/"},{"name":"陈奕迅","slug":"陈奕迅","permalink":"http://example.com/tags/%E9%99%88%E5%A5%95%E8%BF%85/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"查找","permalink":"http://example.com/tags/%E6%9F%A5%E6%89%BE/"}]}